Francisco David Mejia Rodríguez

MÓDULO I
DISEÑO DE BASES DE DATOS
1. Diseño de bases de datos
1.1 Elementos del análisis semántico
1.2 Desarrollo de un diagrama entidadrelación y diagrama entidadrelación extendido
1.3 Derivación de tablas a partir de un diagrama entidad - relación
2. Modelo relacional y diseño de bases de datos
2.1 Dependencias funcionales
2.2 Proceso de normalización
2.3 Formas normales (1ª, 2ª y 3ª)
3. Casos de estudio

MÓDULO II
CONSTRUCCIÓN DE LA BASE DE DATOS
1. El lenguaje SQL
1.1. Versiones
2. Creación de la base de datos
2.1. Opciones para la creación de la base de datos
3. Programación por comandos y por scripts
4. Construcción de la base de datos
4.1. Tablas
4.1.1. Creación y modificación de tablas
4.1.2. Uso de valores por predeterminadas
4.1.3. Construir tablas a partir de otras
4.2. Modificación de datos
4.2.1. Agregar
4.2.2. Eliminar
4.2.3. Actualizar
4.3. Manejo de secuencias
4.4. Integridad de datos
4.4.1. Integridad de columna
4.4.1.1 Not null
4.4.1.2 Check
4.4.1.3 Unique
4.4.1.4 Primary Key
4.4.2 Integridad Referencial
4.4.2.1 Foreign key
4.5 Manejo de Índices

MÓDULO III
PROGRAMACIÓN DE CONSULTAS DE BASES DE DATOS
1. Restricción de renglones
1.1. Operadores
1.1.1 De búsqueda
1.1.2 Lógicos
1.1.3 Operación con nulos
1.1.4 Agregados del estándar SQL 92
1.1.4.1 IN y NOT IN
1.1.4.2 BETWEEN y NOT BETWEEN
1.1.5 Operadores de cadenas
2. Ordenamiento
3. Consultas de varias tablas
3.1. Operaciones de álgebra relacional
3.1.1 Unión
3.1.2 Intersección
3.1.3. Diferencia
3.1.4. Junta de tablas
3.1.4.1 Cross join
3.1.4.2 Inner join
3.1.4.3 Outer join
3.1.4.4 Self join
4. Cálculo relacional
4.1. Uso de operadores EXISTS, ANY, SOME Y ALL
5. Instrucción CASE WHEN
6. Sub-consultas
7. Consultas de agrupamiento
7.1. Funciones de agregado
7.2. Restringiendo grupos con HAVING
7.3. Cálculos entre grupos
8. Operadores avanzados
9. Plan de ejecución de consultas
10. Creación de vistas
11. Consultas especializadas

MÓDULO IV
PROGRAMACIÓN AVANZADA DE BASES DE DATOS
1. Lenguajes de programación de bases de datos
1.1. PL/SQL
1.2. Transact-SQL
1.3. Otros
2. Procedimientos almacenados de base de datos
2.1. Programación de disparadores
2.2. Programación de procedimientos
2.3. Programación de funciones
3. Manejo de transacciones
3.1. Funcionamiento de una transacción
3.2. El LOG de transacciones
3.3. Recuperación de transacciones
3.4. Programación de transacciones
4. Cursores
4.1. Conceptos básicos
4.2. Cursores en procedimientos almacenados
5. Características orientadas a objetos
5.1. Herencia de tablas
5.2. Tipos de datos complejos
5.2.1. Manejo de arreglos
5.3. Tipos de datos definidos por el usuario

MÓDULO V
ADMINISTRACIÓN DE LA BASE DE DATOS
1. Funciones del DBA
2. Administración del servidor
2.1. Detener, arrancar y reiniciar un servidor
2.2. Opciones de arranque
3. Administración del catálogo
3.1. Tablas del sistema
3.2. Vistas del sistema
4. Importación y exportación de datos
5. Monitoreo del sistema
6. Programación de tareas rutinarias
7. Ajustes de configuración de rendimiento
8. Optimización de consultas

MÓDULO VI
SEGURIDAD DE BASES DE DATOS
1. Seguridad
1.1. Esquemas de acceso a servidores de bases de datos
1.2. Administración de usuarios
1.3. Administración de grupos
1.4. Administración de roles
1.5. Administración de privilegios
1.6. Restricciones de acceso al servidor
2. Respaldos
2.1. Generación automática de scripts
2.2. Creación de respaldos
2.3. Restauración de respaldos
3. Desarrollo de planes de contingencia

MÓDULO VII
CONECTIVIDAD A BASES DE DATOS
1. Arquitectura de aplicaciones
1.1. Conceptos básicos
1.2. Modelo de dos capas
1.3. Modelo de tres capas
2. Librerías de conectividad
3. Ejecución de actualizaciones desde una interfaz
4. Ejecución de consultas desde una interfaz
5. Manejo de procedimientos almacenados desde una interfaz
6. Construcción de aplicaciones
6.1. Creación de aplicaciones web de dos capas
6.2. Creación de aplicaciones web de tres capas

MÓDULO VIII
MANEJADORES DE BASES DE DATOS COMERCIALES
1. PostgreSQL
2. Oracle
3. DB2 Universal Database
4. SQL Server
5. Otros

MÓDULO IX
LABORATORIO
Objetivo específico:
El alumno integrará los conocimientos adquiridos en los módulos anteriores y los aplicará en la relación de trabajo asignada por el expositor.

IoT y Modelos de datos





La ciencia de datos en otros campos
David Mejía

Agenda
◆ Antecedentes
	✔ Big Data
◆ ¿Qué es Big Data?
	✔ Las 4V’s del Big Data
	✔ Inteligencia de Negocios
◆ Big Data y Analytics
◆ Ciencia de datos
	✔ ¿Qué es la ciencia de datos?
	✔ Perfil del científico de datos
◆ Conclusiones

1. Analítica artesanal: Habilidades básicas de negocios y quants
2. Análisis de Big Data: Datos de estructuración y experimentos
3. Análisis de economía de datos: Productos y decisiones a escala industrial; grandes cambios
4. Análisis cognitivo: Tecnología de vanguardia y capacidad analítica

10 industrias que han adoptado el análisis
◆ Deportes profesionales
◆ Servicios financieros
◆ Transportes y viajes
◆ Telecomunicaciones
◆ Fabricación industrial
◆ Automovilístico
◆ Medios de comunicación y entretenimiento
◆ Salud
◆ Recursos naturales
◆ Leyes

10 fuentes de datos
◆ Clickstreams
◆ Redes sociales
◆ Internet de las cosas
◆ Telemática
◆ Genómica
◆ Seguimiento de actividades
◆ Uso de teléfonos celulares
◆ Imágenes etiquetadas
◆ Datos abiertos del gobierno

La base de esta revolución son los DATOS
• Internet de las cosas
• La genómica y precisión médica
• Ciencia de datos
• Aprendizaje automatizado
• Inteligencia artificial (AI)
• Vehículos autónomos

¿Qué es BIG DATA?
Es la manipulación de gran cantidad de datos, con relevancia en volumen masivo, variedad y velocidad lo que hace complejo capturarla, almacenarla clasificarla y categorizarla.

Tareas de BIG DATA
✔ Diseñar
✔ Mejorar
✔ Mantener
✔ Comercializar
✔ Usar
✔ Estudia

BIG DATA
• ¿Cómo se origina?
Por la explosión en la cantidad (velocidad y frecuencia) y diversidad de datos digitales generados en tiempo real como resultado del rol cada vez mayor de la tecnología en las actividades diarias.
• ¿Para qué sirve?
Permite generar información y conocimiento con base en información completa en tiempo real.

BIG DATA
• Big Data hace referencia a los sistemas que manipulan grandes conjuntos de datos, también conocidos como data sets.
• Principales cualidades: heterogeneidad, volatilidad.
• Mayores dificultades al trabajar a nivel de BIG DATA: volumen y velocidad.

BIG DATA RETOS:
◆ Captura de datos.
◆ Almacenamiento de tales volúmenes de información.
◆ Capacidad de realizar búsquedas eficientes.
◆ Compartición.
◆ Posibilidad de llevar a cabo análisis efectivos.
◆ Visualización de los datos.

BIG DATA PARA LA CREACIÓN DE VALOR
• Segmentación de mercado y población para personalizar acciones 
• Innovación en nuevos modelos de negocios, productos y servicios 
	-Mejora de productos existentes 
	-Desarrollo de nuevos productos (masa y personalización) 
	-Nuevos modelos de servicio a nivel empresarial y gubernamental
• Apoyo a la toma de decisiones con software inteligente 
• Transparencia y eficiencia por compartir datos 
• Mejor y más oportuno análisis de desempeño de las organizaciones y ajustes en acción.

Las 4 Ps del Marketing
Producto
Precio
Punto de venta
Promoción

Precio VS Valor

Las 4 Vs del Big Data:
* Volumen
* Variedad
* Velocidad
* Veracidad

Data Tsunami: 

Inteligencia de negocios de próxima generación: La brecha entre estratégico, táctico y operativo
1. Estrategia
2. Gestión corporativa
3. Estrategia de entidades
4. Gestión de entidades
5. Estrategia de operaciones
6. Gestión operativa
7. Infraestructura de sistemas informáticos
------------------
Estratégico (Servicios de toma de decisiones): 1 y 2
	Cuadro de mando integral
	Gestión del rendimiento empresarial
Táctico (Servicios transaccionales): 3, 4 y 5
	Planeación de negocios de análisis predictivo de detección de tendencias
Operativo: 6 y 7
	Informes operativos
	Gestión de eventos

Inteligencia de Negocios:
* Clientes
* Financiero
* Riesgos
* Canales

TIPOS DE DATOS:
• Compras y transacciones 
• Datos de gestión empresarial 
• Búsqueda (consulta, trayectoria recorrida, historia) 
• Sociales (datos de identidad, información general) 
• Intereses personales (que me gusta, tweets, etc.) 
• Ubicación, sensores físicos (GPS, patrones de tráfico, Internet of Things, etc.) 
• Contenido (SMS, llamadas, e-mails)

IMPLICACIONES:
• Era caracterizada por la abundancia de datos. 
	• Ha alcanzado todos los sectores en la economía. 
	• Los datos son un nuevo factor de producción y de ventaja competitiva. 
• Oportunidad: 
	• Aprender sobre el comportamiento humano para diversos fines. 
	• Creación de valor vía innovación, eficiencia y competitividad.
• Nuevas formas de competencia y nuevos negocios
	• Almacenamiento y gestión de datos. 
	• Análisis de datos empresariales. En 2010 se estimaba el valor de esta industria en más de $100 mil millones, creciendo a casi un 10% al año.

Analytics: capacidades
• La analítica de grandes datos se refiere a las herramientas y metodologías para transformar cantidades masivas de datos brutos en “datos sobre datos” con propósitos analíticos. 
• Se originó en las áreas de biología intensiva en cómputo, ingeniería biomédica, medicina y electrónica. 
• Algoritmos para detectar patrones, tendencias y correlaciones, en varios horizontes temporales, en los datos. 
• Uso de técnicas avanzadas de visualización: datos que hacen sentido.

PROBLEMÁTICA:
• Disponibilidad de datos: asimetrías 
	-Las redes sociales generan datos abiertos 
	-Los gobiernos los están abriendo, lentamente 
	-Los datos de empresas siguen cerrados 
• Diferentes capacidades de buscar y analizar datos
• Falta de incentivos para compartir datos
• Privacidad y los límites al anonimato de conjuntos de datos
• Una buena parte de las nuevas fuentes de datos reflejan sólo percepciones, intenciones y deseos 
• ¿Qué sucede cuando las técnicas de análisis tradicionales se encuentran con sus límites? 
• ¿Cuándo llega el momento en que la minería de datos no aporta las soluciones esperadas? 
• ¿Cómo se enfrentan al desafío de los grandes datos y su expresión más desestructurada?
• Aquí es donde entra en juego lo que se conoce como Data Science (técnicas necesarias para manipular y tratar la información desde un punto de vista estadístico/matemático).
• Data Science está basado en algoritmos, aplicados al problema de BIG DATA, entre otros. 
• Implica hallar correlaciones, aplicar algoritmos más complejos y proporcionar niveles de visibilidad que transforman el contacto de una entidad con su entorno
• También la capacidad de descubrir y estudiar oportunidades.
• Incorporar la figura del data scientist en la organización.

Perfil de un científico de datos:
* Scientific Method
* Math
* Statistics
* Advanced Computing
* Visualization
* Hacker Mindset
* Domain Expertise
* Data Engineering

Perfil de un científico de datos:
• Aprender a codificar: desde el nivel más básico, relativo a Java, C++/Go y Scala/Clouje; hasta el más sofisticado que comprende Python, lenguaje R.
• Aportar conocimientos estadísticos necesarios: sumatoria, creación de hipótesis, análisis bayesianos o distribuciones.
• Comprender los pormenores del modelación matemática y computacional: validaciones y comparaciones de modelos.
• Tener capacidades de ingeniería de software: computación distribuida, visualización de datos, algoritmos y estructuras de datos.
• Contar con una sólida base de matemáticas: desde probabilidad y combinatoria hasta álgebra lineal, pasando por todo lo relativo al cálculo de integrales, derivadas, etc.

Perfil de un científico de datos:
	Transversal e integrador de disciplinas
	• Matemáticas
	• Estadística
	• Programación
	• Mineria de datos
	Demanda de profesionales a nivel de posgrado
	• Farmaceútica
	• Software
	• Internet
	• TIC y servicios
Para 2018 se requerió 140,000 a 190,000 científicos de datos.

FASES DE BIG DATA Y SUS SOLUCIONES CON HADOOP:
1.Descubrimiento de grandes datos
	• Definir cuáles son los datos de interés.
	• Encontrar sus fuentes (históricos o Social Media, entre otros).
	• Grabar los datos en el sistema.
	• Determinar cómo serán procesados.
2.Extracción y limpieza de los grandes volúmenes de datos
	• Extraer los datos de la fuente de origen datos.
	• Perfilar y limpiar los datos.
	• Adecuarlos a las necesidades.
	• Aplicar los estándares de calidad de datos.
3. Estructuración y análisis de big data
	• Dotar de estructura lógica a los conjuntos de datos tratados.
	• Almacenar los datos en el repositorio elegido (puede ser una base de datos o un sistema).
	• Analizar los datos disponibles para hallar relaciones.
4. Modelado de datos
	• Aplicar algoritmos a los datos.
	• Aplicar procesos estadísticos.
	• Resolver las peticiones lanzadas mediante el modelado de datos en base a técnicas de minería.
5. Interpretación de grandes datos
	• Interpretar las distintas soluciones.
	• Aportar un resultado final.

ETL: Extract, Transform and Load

CRECIMIENTO DE LOS DATOS VS CRECIMIENTO DE LOS ANALISTAS DE DATOS
Los datos almacenados se acumulan con una tasa de crecimiento anual del 28%, mientras que la fuerza de trabajo correspondiente a analistas de datos tan solo aumenta un 5,7% por año.

¿Qué pasará en América Latina en los próximos años? 
• Big Data y Analítica (BDA)
Se calcula inversión de 1.4 mil MDD en América Latina. La línea de negocios se involucrará de manera más profunda en las decisiones de implementación tecnológica con los responsables de Tecnología. 
• Internet de la Cosas (IoT)
Habrá 291 millones de objetos conectados en América Latina, lo que significa un aumento del 20% comparado con 2014. Para 2020 el número de ‘cosas’ conectadas se elevará a los 600 millones. El 75% del gasto en IoT para los próximos años provendrá de SW y de aplicaciones.


Profesor Edgar Frank Codd


Algebra Relacional
https://es.wikipedia.org/wiki/Relaci%C3%B3n_de_equivalencia
https://youtu.be/0X0SThhVYRc
https://laboratoriomatematicas.uniandes.edu.co/semarquitec/simbolosmat.htm
Relación de equivalencia: En teoría de conjuntos y álgebra, la noción de relación de equivalencia sobre un conjunto permite establecer una relación entre los elementos del conjunto que comparten cierta característica o propiedad. Esto permite reagrupar dichos elementos en clases de equivalencia, es decir, «paquetes» de elementos similares. Esto posibilita la construcción de nuevos conjuntos «añadiendo» todos los elementos de una misma clase como un solo elemento que los representará y que define la noción de conjunto cociente.

Relación de equivalencia:
Reflexividad:
	El elemento 'a' es del conjunto 'A', entonces 'a' se relaciona consigo mismo 'a'.
	"a ∈ A" => "a R a"
Simetría:
	"a R b" => "b R a"
Transitividad:
	"a R b" y "b R c" => "a R b R c" => "a R c"

Ejemplo 1:
A = {w,x,y,z}
R = {(w,w),(w,y),(x,x),(y,w),(y,y),(z,z)}
Reflexiva:
	(w,w)
	(x,x)
	(y,y)
	(z,z)
Simetrica:
	(y,w) => (w,y)
	(w,y) => (y,w)
	(w,w)
	(x,x)
	(y,y)
	(z,z)
Transitiva:
	(w,w) y (w,y) => (w,y)
	(w,y) y (y,w) => (w,w)
	(w,y) y (y,y) => (w,y)
	(x,x)
	(y,w) y (w,w) => (y,w)
	(y,w) y (w,y) => (y,y)
	(y,y)
	(y,y) y (y,w) => (y,w)
	(z,z)
DUDA: ¿Pero esto no es "estupido"?, porque estas 3 reglas pueden generar redundancia/ambiguedad al ser tan simples. Por ejemplo en "transitiva", (z,z) el par que comienza con 'z' ese mismo par "(z,z)", ya que 'z' se relaciona consigo mismo transitivamente. Pero la "reflexiva" generó exactamente el mismo resultado.

Diagramas ERA (Entity Relation)

Modelo Conceptual => Modelo Lógico => Modelo Físico

FN 1: Una llave
FN 2: Todos los atributos de esa tabla dependan de la llave
FN 3: Dependencia funcional










Reglas de Codd










Diseño y Creación de una Base de Datos
Integridad de los Datos:
• La integridad de los datos es la integridad general, la precisión y la coherencia de los datos.
• Esto puede indicarse por la ausencia de alteración entre dos instancias o entre dos actualizaciones de un registro de datos, lo que significa que los datos están intactos y sin cambios.
• La integridad de los datos generalmente se impone durante la fase de diseño de la base de datos mediante el uso de procedimientos y reglas estándar.
• La integridad de los datos se puede mantener mediante el uso de varios métodos de verificación de errores y procedimientos de validación.
• La integridad de los datos se aplica tanto en modelos de bases de datos jerárquicas como relacionales.
• Las siguientes tres restricciones de integridad se utilizan en una estructura de base de datos relacional para lograr la integridad de los datos:
	– Integridad de la entidad: se trata del concepto de llaves primarias. La regla establece que cada tabla debe tener su propia clave principal, y que cada una debe ser única y no nula.
	– Integridad referencial: este es el concepto de llaves foráneas. La regla establece que el valor de la clave foránea puede estar en dos estados. El primer estado es que el valor de la llave foránea se referiría a un valor de llave primaria de otra tabla, o puede ser nulo. Ser nulo podría significar simplemente que no hay relaciones, o que la relación es desconocida.
	– Integridad del dominio: indica que todas las columnas en una base de datos relacional están en un dominio definido.
• El concepto de integridad de datos garantiza que todos los datos en una base de datos puedan rastrearse y conectarse a otros datos.
• Esto asegura que todo sea recuperable y accesible.
• Tener un sistema de integridad de datos único, bien definido y bien controlado aumenta la estabilidad, el rendimiento, la reutilización y la capacidad de mantenimiento.
• Si una de estas características no puede implementarse en la base de datos, debe implementarse a través del software.
• Por otro lado, C.J. Date cita que “el término integridad se refiere a la exactitud o correción de los datos en la base de datos … una base de datos determinada podría estar sujeta a cualquier cantidad de restricciones de integridad (en general) de una complejidad arbitraria”.
• Es importante conceptualizar que la integridad de datos se refiere al hecho de que los datos deben ser confiables y precisos en todo su ciclo de vida. Se espera que el dato sea:
	– Atribuible: los datos deben demostrar claramente quién los observó y grabó, cuándo fueron observados y registrados, y de quién se trata.
	– Legible: los datos deben ser fáciles de entender, registrar de forma permanente y las entradas originales deben conservarse.
	– Contemporáneo: los datos se deben registrar tal como se observaron, y en el momento en que se ejecutó.
	– Original: los datos de origen deben ser accesibles y conservados en su forma original.
	– Preciso: los datos deben estar libres de errores, y cumplir con el protocolo.
	– Cloud.

Diseño y Creación de una Base de Datos:
• Una base de datos puede contener múltiples tablas, cada una con información sobre un tipo de información (sustantivos/tablas) que se almacenará en la base de datos.
• Por ejemplo, una base de datos de empleados puede tener una tabla para el departamento al que pertenecen los empleados, una para los empleados, y otra para las deducciones vía nómina a cada empleado.
• Cada tabla contiene información detallada (atributos/columnas) sobre el artículo u objeto en particular; cada uno contiene, como mínimo, la siguiente información:
	DEPARTAMENTOS			EMPLEADOS					DEDUCCIONES_EMPLEADO
	Departamento_ID			Empleado_ID					Empleado_ID
	Departamento_Nombre		Empleado_PrimerNombre		Deduccion_Codigo
	Departamento_Gerente_ID	Empleado_ApellidoPaterno	Deduccion_Monto
							Empleado_ApellidoMaterno	Deduccion_Quincena
							Empleado_TelefonoOficina	Deduccion_Año
							Empleado_TelefonoCasa
							Empleado_Domicilio
							Empleado_CodigoPostal
							Empleado_Ciudad
							Empleado_Estado
							Empleado_Email
							Departamento_ID
• Cuando se cargan las tablas, la información para cada ocurrencia se carga como un registro en la tabla respectiva, y cada elemento o valor de datos se asocia con su respectiva columna en la tabla.
• Por ejemplo, un registro en la tabla DEPARTAMENTOS puede tener el siguiente contenido:
┌─────────────────┬──────────────────────────────────────┬─────────────────────────┐
│ Departamento_ID │          Departamento_Nombre         │ Departamento_Gerente_ID │
├─────────────────┼──────────────────────────────────────┼─────────────────────────┤
│   CDMX_VTAS_1   │ Mercadotecnia en Centros Comerciales │          V0104          │
└─────────────────┴──────────────────────────────────────┴─────────────────────────┘
• Al analizar la tabla EMPLEADOS, el primer registro para un empleado asignado al departamento mencionado previamente puede mostrarse de la siguiente manera:
┌─────────────┬───────────────────────┬──────────────────────────┬─────┬─────────────────┐
│ Empleado_ID │ Empleado_PrimerNombre │ Empleado_ApellidoPaterno │ ... │ Departamento_ID │
├─────────────┼───────────────────────┼──────────────────────────┼─────┼─────────────────┤
│    V0104    │          Juan         │          Torres          │     │   CDMX_VTAS_1   │
└─────────────┴───────────────────────┴──────────────────────────┴─────┴─────────────────┘
• Considere que la relación entre el registro Departamento para la unidad de Mercadotecnia en Centros Comerciales y el registro Empleado para Juan Torres se determina porque Departamento_ID, "CDMX_VTAS_1", se almacena como valor de la columna Departamento_ID en la tabla EMPLEADOS.
• Esto ilustra la relación uno a muchos entre DEPARTAMENTOS y EMPLEADOS, conociéndolo como Integridad Referencial.
┌─────────────────┬──────────────────────────────────────┬─────────────────────────┐
│ Departamento_ID │          Departamento_Nombre         │ Departamento_Gerente_ID │
├─────────────────┼──────────────────────────────────────┼─────────────────────────┤
│   CDMX_VTAS_1   │ Mercadotecnia en Centros Comerciales │          V0104          │
└─────────────────┴──────────────────────────────────────┴─────────────────────────┘
┌─────────────┬───────────────────────┬──────────────────────────┬─────┬─────────────────┐
│ Empleado_ID │ Empleado_PrimerNombre │ Empleado_ApellidoPaterno │ ... │ Departamento_ID │
├─────────────┼───────────────────────┼──────────────────────────┼─────┼─────────────────┤
│    V0104    │          Juan         │          Torres          │     │   CDMX_VTAS_1   │
└─────────────┴───────────────────────┴──────────────────────────┴─────┴─────────────────┘
• Algunos profesionales de la informática, especialistas en bases de datos, también le nombran relación Maestro-Detalle.
• Lo anterior se debe a que una entidad Maestro tiende a tener por lo menos un Detalle; con el ejemplo previo, podríamos citar que la relación Maestro-Detalle de DEPARTAMENTOS y EMPLEADOS es que “un departamento puede tener asignado cuando menos un empleado”, o “el departamento de Mercadotecnia en Centros Comerciales tiene seis empleados asignados”, según sea el caso.
• La integridad referencial es fundamental para la integridad de los datos, se activa y aplica a través de un Manejador de Bases de Datos Relacionales (RDBMS, Relational Database Management System) a medida que los datos se insertan o eliminan en tablas individuales. Por ejemplo:
	– Cualquier valor de Departamento_ID asignado a un nuevo empleado debe coincidir con un valor de Departamento_ID en la tabla DEPARTAMENTOS.
	– Cualquier registro nuevo de DEDUCCIONES_EMPLEADO debe contener una Identificación (ID) de empleado válido o coincidente.
	– Más importante, ya sea si un empleado renuncia o es despedido, todos los registros en DEDUCCIONES_EMPLEADO (relacionados al empleado citado) tenderán a ser eliminados automáticamente sin que el programador tenga que realizar esa función.

Integridad de los Datos:
• Las doce reglas del Dr. E.F. Codd para bases de datos relacionales.
• Las bases y los fundamentos de la teoría relacional inician con las reglas que formuló el Dr. E.F. Codd en las publicaciones de Octubre 14 y 21 de 1985 en la revista Computerworld con los artículos "¿Es su DBMS realmente relacional?" y "¿Funciona su DBMS según las reglas?", respectivamente.
• Estas reglas van más allá de la teoría relacional y definen criterios más específicos que deben cumplirse en un RDBMS, para que sea verdaderamente relacional.

Las 12 Reglas de Codd:
1. Regla de la información: Toda la información en una base de datos relacional debe ser representada explícitamente, al nivel lógico, en exactamente una manera, por valores en tablas.
2. Regla de acceso garantizado: Todos y cada uno de los valores de datos en una base de datos relacional deben ser accesibles lógicamente mediante una combinación del nombre de tabla, nombre de columna y valor de la llave primaria.
3. Regla de tratamiento sistemático de valores nulos: Los valores nulos (distintos de la cadena de caracteres vacía, de una cadena de caracteres en blanco, distinta de cero, o de cualquier otro número) son soportadas completamente con las relaciones del RDBMS para representar información faltante en forma sistemática, independientemente del tipo de datos.
4. Diccionario de datos dinámico basado en el modelo relacional: La descripción de la base de datos es representada dinámicamente, al nivel lógico, como datos ordinarios, de tal forma que los usuarios autorizados puedan aplicar el mismo lenguaje relacional para consultarlas.
5. Lenguaje de datos comprensible: No importa cuántos lenguajes y modelos interactivos se soporten, por lo menos un lenguaje debe ser soportado, con una sintáxis bien definida, que soporte interactivamente y por programa lo siguiente:
	a) Definición de datos.
	b) Reglas de integridad.
	c) Manipulación de datos.
	d) Vistas.
	e) Control de transacciones.
	f) Reglas de autorización.
6. Regla de actualización de vistas: Para cada vista el DBMS debe tener una forma de determinar, en el momento de la definición de la vista, si la vista puede ser utilizada para insertar renglones, borrar renglones, actualizar columnas sobre las tablas en las que esta basada, y guardar los resultados de ésta decisión en el catálogo del sistema.
7. Regla de operaciones de conjuntos: La capacidad de operar en tablas completas no sólo se aplica a la consulta, sino también a la inserción, modificación y borrado de datos. Las operaciones de conjuntos, independientes de la estructura física de los datos, se logran gracias a un proceso llamado optimización que es único para las bases de datos relacionales.
8. Regla de independencia física de los datos: Esto se refiere a una separación, hecha por el DBMS, de los aspectos físicos y lógicos de la base de datos. Las operaciones interactivas y los programas de aplicación no deben ser modificados cuando cambian las estructuras internas de almacenamiento y los métodos de acceso a la base de datos.
9. Regla de independencia lógica de los datos: Las operaciones interactivas y los programas de aplicación no deben ser modificados, cuando se realizan cambios sobre las estructuras de las tablas de la base de datos que no involucren pérdida de información.
10. Regla de independencia de integridad: Las operaciones interactivas y los programas de aplicación no deben ser modificados cuando se realizan cambios sobre las reglas de integridad definidas y almacenadas en el catálogo del sistema de la base de datos.
11. Regla de independencia de distribución:
	o Esta regla se refiere alos DBMS distribuídos. El concepto de independencia de distribución es similar a las reglas de independencia física, lógica y de integridad discutidas, pero aplicadas a distribución a través de computadoras.
	o Esta regla implica que todas las características y reglas requeridas por el modelo deben extenderse a todo el sistema distribuído.
	o La distribución de datos o de procesamiento en general, y la distribución de DBMS en particular son temas cada vez más populares.
12. Regla de la no subversión: Si un DBMS se maneja con un lenguaje de bajo nivel, procedural, esto no debe de representar el omitir las reglas de integridad y de seguridad que se contemplan con el uso de un lenguaje de alto nivel, y que son almacenadas en el diccionario de la base de datos.

Derivación de tablas a partir de un diagrama entidad-relación
Creación de Tablas:
• Cuando se usa una base de datos, los datos se almacenan en tablas (listas basadas en asuntos que contienen datos organizados en registros).
• Por ejemplo, puede crear una tabla Contactos para almacenar una lista de nombres, direcciones de correo electrónico y números de teléfono.








Proyecto final para el 18
	Conceptual
	Logico
	3FN
	Agregar algunas consultas SQL

Nuevo Entorno Digital: Volatilidad (V), Incertidumbre (U), Complejidad (C), Ambiguedad (A)

Pilares de.....
Vision y Estrategia
Liderazgo y Cutura
Tecnología y Progreso

Amazon tiene alrededor de 1,500 errores en sus sistemas y su equipo de CERT es llamado "Simian Team".







Diagrama Entidad-Relación
Semiótica: Estudio de los signos y sistemas de signos. Ayuda a describir, analizar e interpretar la comunicación...

Integridad de datos: Atributos, ...
Precision y coherencia de datos.


Vuelo
Cliente
Sesion
Compra

Cliente muchos Vuelo
Vuelo muchos Cliente
Cliente muchos Sesion
Sesion un Cliente
Vuelo muchas Compra
Compra un Vuelo
Compra muchos Sesion
Sesion muchos Compra
Vuelo un Sesion
Sesion un Vuelo









 
Entidad fuerte: 
Entidad debil:







Introduction
Construct SQL queries using basic Commands: SELECT, FROM, WHERE, GROUP BY, HAVING, ORDER BY
Combine / Stack Data using JOIN and UNION Commands
Use Operators: Relational, Arithmetic, Logical
Utilize Subqueries

What is SQL (pronounced ‘See-kwel’)?
Structured Query Language (SQL) is a programming language designed to manipulate and extract data from a Relational Database Management System (RDBMS)
• Invented in the early 1970’s at IBM and based on relational algebra
• Became and American National Standards Institute (ANSI) standard in 1986 and in International Standards Organization (ISO) standard in 1987
Queries are pieces of code that retrieve data from database tables
Data Manipulation or Data Definition operations are used to create or alter the database itself
Different, proprietary versions of the language exist, but most are almost identical in basic syntax;
• This makes knowledge of SQL a highly transferable skill
• This is good, since in the real world it’s the workhorse behind data analytics
• It’s also a remarkably simple language, particularly relative to its power



SQL – Basic Functions
SELECT: Defines which attributes / columns / fields I want to retrieve or calculate (Mandatory)
FROM: Identifies the table from which I want to extract information (Mandatory)
WHERE: Adds filters that restrict what rows / records are retrieved (Optional)
GROUP BY: Defines the level of aggregation I want if I am summarizing data (Optional)
HAVING: Adds filters that restrict what aggregated rows / records are retrieved (Optional)
ORDER BY: Defines the sort order of the results



SQL – The SELECT Statement & FROM Clause
SELECT: Defines which attributes / columns / fields I want to retrieve or calculate
FROM: Identifies the table from which I want to extract information

SELECT FIELD_1, FIELD_2, ..., FIELD_N
FROM TABLE_NAME;
SELECT FIELD_1, FIELD_2, ..., FIELD_N FROM TABLE_NAME;

TRANSACTIONS
┌────────────────┬─────────────┬─────────┬─────────┬───────┬──────────┐
│ Transaction_ID │ Customer_Id │ Channel │ Product │ Price │ Discount │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000123    │    60067    │   Web   │   Book  │  9.95 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000124    │    12345    │  Store  │   Book  │ 11.95 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000125    │    23451    │  Store  │   DVD   │ 14.95 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000126    │    70436    │ Reseller│   DVD   │ 19.95 │    5     │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000127    │    66772    │  Store  │ Magazine│  3.25 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000128    │    60067    │   Web   │   Book  │ 29.95 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000129    │    72045    │   Web   │   DVD   │  9.95 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000130    │    82371    │ Reseller│ Magazine│  2.5  │   0.25   │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000131    │    12345    │  Store  │   Book  │  7.95 │          │
└────────────────┴─────────────┴─────────┴─────────┴───────┴──────────┘
SELECT CHANNEL, PRODUCT, PRICE
FROM TRANSACTIONS;
┌─────────┬─────────┬───────┐
│ Channel │ Product │ Price │
├─────────┼─────────┼───────┤
│   Web   │   Book  │  9.95 │
├─────────┼─────────┼───────┤
│  Store  │   Book  │ 11.95 │
├─────────┼─────────┼───────┤
│  Store  │   DVD   │ 14.95 │
├─────────┼─────────┼───────┤
│ Reseller│   DVD   │ 19.95 │
├─────────┼─────────┼───────┤
│  Store  │ Magazine│  3.25 │
├─────────┼─────────┼───────┤
│   Web   │   Book  │ 29.95 │
├─────────┼─────────┼───────┤
│   Web   │   DVD   │  9.95 │
├─────────┼─────────┼───────┤
│ Reseller│ Magazine│  2.5  │
├─────────┼─────────┼───────┤
│  Store  │   Book  │  7.95 │
└─────────┴─────────┴───────┘

Special Case – What if I want to select ALL columns / fields?
• Could type them all out in the SELECT statement, but tedious
• Instead, use the ‘wildcard’ character *

SELECT *
FROM TABLE_NAME;



SQL – The WHERE Clause
WHERE: Adds filters that restrict what rows / records are retrieved
WHERE <logical_condition(s)>

SELECT *
FROM TRANSACTIONS
WHERE CHANNEL = 'STORE';
┌────────────────┬─────────────┬─────────┬─────────┬───────┬──────────┐
│ Transaction_ID │ Customer_Id │ Channel │ Product │ Price │ Discount │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000124    │    12345    │  Store  │   Book  │ 11.95 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000125    │    23451    │  Store  │   DVD   │ 14.95 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000127    │    66772    │  Store  │ Magazine│  3.25 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000131    │    12345    │  Store  │   Book  │  7.95 │          │
└────────────────┴─────────────┴─────────┴─────────┴───────┴──────────┘
SELECT CHANNEL, PRODUCT, PRICE
FROM TRANSACTIONS
WHERE CHANNEL = 'STORE';
┌─────────┬─────────┬───────┐
│ Channel │ Product │ Price │
├─────────┼─────────┼───────┤
│  Store  │   Book  │ 11.95 │
├─────────┼─────────┼───────┤
│  Store  │   DVD   │ 14.95 │
├─────────┼─────────┼───────┤
│  Store  │ Magazine│  3.25 │
├─────────┼─────────┼───────┤
│  Store  │   Book  │  7.95 │
└─────────┴─────────┴───────┘



SQL – Aggregations
Aggregation: Takes values in multiple rows of data and returns one value
SUM(FIELD_NAME)
AVG(FIELD_NAME)
MIN(FIELD_NAME)
MAX(FIELD_NAME)
COUNT(FIELD_NAME) or COUNT(*) 

• SUM and AVG require that the field be numeric
• MIN and MAX will work with a variety of data types

NULL: Represents the absence of data
• Not the same as a zero (numeric value) a space (text value)
• All aggregate functions except COUNT ignore NULL values
• COUNT(FIELD_NAME) and COUNT(*) give different values if NULLs present

SELECT COUNT(*) 
FROM TRANSACTIONS;
SELECT COUNT(*) AS NUM_ROWS
FROM TRANSACTIONS;

• NUM_ROWS is the ‘Alias’ for COUNT(*) and is designated using ‘AS’



SQL – The GROUP BY Clause
GROUP BY: Defines the level of aggregation I want if I’m summarizing data

SELECT GROUP_FIELD_1, ..., GROUP_FIELD_N,
 <AGGREGATE_1>, ..., <AGGREGATE_2>
FROM TABLE_NAME
GROUP BY GROUP_FIELD_1, ..., GROUP_FIELD_N;

• GROUP_FIELD(s) must match in SELECT and GROUP BY clauses
• Everything else in the SELECT statement must be an aggregate function, e.g.:
SUM(FIELD_NAME)
AVG(FIELD_NAME)
MIN(FIELD_NAME)
MAX(FIELD_NAME)
COUNT(FIELD_NAME) or COUNT(*)

Let’s say I want to know the following by Product:
• Total number of purchases by product
• Total dollar value of purchases by product
• Average dollar value of purchases by product
┌────────────────┬─────────────┬─────────┬─────────┬───────┬──────────┐
│ Transaction_ID │ Customer_Id │ Channel │ Product │ Price │ Discount │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000123    │    60067    │   Web   │   Book  │  9.95 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000124    │    12345    │  Store  │   Book  │ 11.95 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000125    │    23451    │  Store  │   DVD   │ 14.95 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000126    │    70436    │ Reseller│   DVD   │ 19.95 │    5     │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000127    │    66772    │  Store  │ Magazine│  3.25 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000128    │    60067    │   Web   │   Book  │ 29.95 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000129    │    72045    │   Web   │   DVD   │  9.95 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000130    │    82371    │ Reseller│ Magazine│  2.5  │   0.25   │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000131    │    12345    │  Store  │   Book  │  7.95 │          │
└────────────────┴─────────────┴─────────┴─────────┴───────┴──────────┘
SELECT PRODUCT, COUNT(*) AS PURCHASES,
 SUM(PRICE) AS TOTAL_SALES,
 AVG(PRICE) AS AVG_SALES
FROM TRANSACTIONS
GROUP BY PRODUCT;
┌─────────┬───────────┬─────────────┬───────────┐
│ PRODUCT │ PURCHASES │ TOTAL_SALES │ AVG_SALES │
├─────────┼───────────┼─────────────┼───────────┤
│   Book  │     4     │    59.8     │   14.95   │
├─────────┼───────────┼─────────────┼───────────┤
│   DVD   │     3     │    44.85    │   14.95   │
├─────────┼───────────┼─────────────┼───────────┤
│ Magazine│     2     │     5.75    │   2.875   │
└─────────┴───────────┴─────────────┴───────────┘



SQL – The HAVING Clause
HAVING Adds filters that restrict what aggregated rows / records are retrieved

SELECT GROUP_FIELD_1, ..., GROUP_FIELD_N,
 <AGGREGATE_1>, ..., <AGGREGATE_2>
FROM TABLE_NAME
GROUP BY GROUP_FIELD_1, ..., GROUP_FIELD_N
HAVING <logical conditions(s)>;

In this case conditions must be applied to one or more of the aggregate functions defined in the SELECT statement.

Let’s start with the results from the GROUP BY example:

SELECT PRODUCT, COUNT(*) AS PURCHASES,
 SUM(PRICE) AS TOTAL_SALES,
 AVG(PRICE) AS AVG_SALES
FROM TRANSACTIONS
GROUP BY PRODUCT;
┌─────────┬───────────┬─────────────┬───────────┐
│ PRODUCT │ PURCHASES │ TOTAL_SALES │ AVG_SALES │
├─────────┼───────────┼─────────────┼───────────┤
│   Book  │     4     │    59.8     │   14.95   │
├─────────┼───────────┼─────────────┼───────────┤
│   DVD   │     3     │    44.85    │   14.95   │
├─────────┼───────────┼─────────────┼───────────┤
│ Magazine│     2     │     5.75    │   2.875   │
└─────────┴───────────┴─────────────┴───────────┘
Now suppose that I only wanted to see products with average sales over $10.
SELECT PRODUCT, COUNT(*) AS PURCHASES,
 SUM(PRICE) AS TOTAL_SALES,
 AVG(PRICE) AD AVG_SALES
FROM TRANSACTIONS
GROUP BY PRODUCT
HAVING AVG_SALES > 10;
┌─────────┬───────────┬─────────────┬───────────┐
│ PRODUCT │ PURCHASES │ TOTAL_SALES │ AVG_SALES │
├─────────┼───────────┼─────────────┼───────────┤
│   Book  │     4     │    59.8     │   14.95   │
├─────────┼───────────┼─────────────┼───────────┤
│   DVD   │     3     │    44.85    │   14.95   │
└─────────┴───────────┴─────────────┴───────────┘

SELECT PRODUCT, COUNT(*) AS PURCHASES,
 SUM(PRICE) AS TOTAL_SALES,
 AVG(PRICE) AD AVG_SALES
FROM TRANSACTIONS
WHERE CHANNEL <> 'RESELLER'
GROUP BY PRODUCT
HAVING AVG_SALES > 10;
┌─────────┬───────────┬─────────────┬───────────┐
│ PRODUCT │ PURCHASES │ TOTAL_SALES │ AVG_SALES │
├─────────┼───────────┼─────────────┼───────────┤
│   Book  │     4     │    59.8     │   14.95   │
├─────────┼───────────┼─────────────┼───────────┤
│   DVD   │     3     │    44.85    │   12.45   │
└─────────┴───────────┴─────────────┴───────────┘



SQL – The ORDER BY Clause
ORDER BY: Defines the sort order of the results

SELECT FIELD_1, FIELD_2, ..., FIELD_N
FROM TABLE_NAME
ORDER BY FIELD_i, ...., FIELD_n;

• By default, sorts in ascending order, but descending can be specified as follows: ORDER BY FIELD_i DESC
• Sorting field(s) can be anything in the source table, whether or not it’s in the SELECT statement

SELECT *
FROM TRANSACTIONS
ORDER BY PRICE DESC;
┌────────────────┬─────────────┬─────────┬─────────┬───────┬──────────┐
│ Transaction_ID │ Customer_Id │ Channel │ Product │ Price │ Discount │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000128    │    60067    │   Web   │   Book  │ 29.95 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000126    │    70436    │ Reseller│   DVD   │ 19.95 │    5     │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000125    │    23451    │  Store  │   DVD   │ 14.95 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000124    │    12345    │  Store  │   Book  │ 11.95 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000123    │    60067    │   Web   │   Book  │  9.95 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000129    │    72045    │   Web   │   DVD   │  9.95 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000131    │    12345    │  Store  │   Book  │  7.95 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000127    │    66772    │  Store  │ Magazine│  3.25 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000130    │    82371    │ Reseller│ Magazine│  2.5  │   0.25   │
└────────────────┴─────────────┴─────────┴─────────┴───────┴──────────┘



SQL – Shorthand using ‘Aliases’
Column Aliases: SELECT COUNT(*) AS NUM_ROWS FROM TRANSACTIONS

Table Aliases: SELECT CHANNEL, PRODUCT, PRICE FROM TRANSACTIONSñ
OR
SELECT TRANSACTIONS.CHANNEL, TRANSACTIONS.PRODUCT, TRANSACTIONS.PRICE FROM TRANSACTIONSñ
OR
SELECT a.CHANNEL, a.PRODUCT, a.PRICE FROM TRANSACTIONS a;
• In this case, ‘a’ is used as an alias for the table



SQL – JOINing Tables
The real power of SQL is the ability to link tables across a relational database structure.
┌─────────┐       ┌─────────┐
│         │   ┌──►│  B.KEY  │
├─────────┤   │   ├─────────┤
│         │   │   │         │
├─────────┤   │   ├─────────┤
│         │   │   │         │
├─────────┤   │   ├─────────┤
│  A.KEY  │◄──┘   │         │
├─────────┤       ├─────────┤
│         │       │         │
├─────────┤       ├─────────┤
│         │       │         │
├─────────┤       ├─────────┤
│         │       │         │
└─────────┘       └─────────┘

                      FULL OUTER JOIN                                                  INNER JOIN                                                 LEFT (OUTER) JOIN
        MMMMMMWKOkkkkkkkOKNMMMMMMN0OkkkkkkkOXWMMMMMM                  MMMMMMWKOkkkkkkkOKNMMMMMMN0OkkkkkkkOXWMMMMMM                  MMMMMMWKOkkkkkkkOKNMMMMMMN0OkkkkkkkOXWMMMMMM        
      MMMMXkxxdxOKKXXXKKOxdxxxxxxdkOKXXXXK0OxxxxONMMMM              MMM                 dxxxxxxd                 MMM              MMMMXkxxdxOKKXXXKKOxdxxxxxxd                 MMM      
     MMXkxx0XXXXXXXXXXXXXKkdodxxk0KXXXXXXXXXXXXKOxxOWMM            MM                  Kkdodxxk0K                  MM            MMXkxx0XXXXXXXXXXXXXKkdodxxk0K                  MM     
    MNddKXXXXXXXXXXXXXXKxld00000OxxOXXXXXXXXXXXXXXXOoxWM          MM                  xld00000OxxO                  MM          MNddKXXXXXXXXXXXXXXKxld00000OxxO                  MM    
   Wko0XXXXXXXXXXXXXXXOld000000000OxkKXXXXXXXXXXXXXXXOoOM        MM                  ld000000000Oxk                  MM        Wko0XXXXXXXXXXXXXXXOld000000000Oxk                  MM   
  WoxXXXXXXXXXXXXXXXX0cO000000000000kdKXXXXXXXXXXXXXXXKdxM      MM                  cO000000000000kd                  MM      WoxXXXXXXXXXXXXXXXX0cO000000000000kd                  MM  
 MddXXXXXXXXXXXXXXXXKcx00000000000000xxXXXXXXXXXXXXXXXXKlkM    MM                  cx00000000000000xx                  MM    MddXXXXXXXXXXXXXXXXKcx00000000000000xx                  MM 
MKcKXXXXXXXXAXXXXXXXdc0000000000000000o0XXXXX┌───┐XXXXXXKcWM  MM          A      Xdc0000000000000000o0     ┌───┐        MM  MKcKXXXXXXXXAXXXXXXXdc0000000000000000o0     ┌───┐        MM
MdoXXXXXXXX/ \KXXXXXcd0000000000000000xxXXXXX│   │XXXXXXXc0M  MM         / \     Xcd0000000000000000xx     │   │        MM  MdoXXXXXXXX/ \KXXXXXcd0000000000000000xx     │   │        MM
ModXXXXXXX/   \XXXXX:x0000000000000000xdXXXXX├───┤XXXXXXXlOM  MM        /   \    X:x0000000000000000xd     ├───┤        MM  ModXXXXXXX/   \XXXXX:x0000000000000000xd     ├───┤        MM
MOlXXXXXX/     \XXXXlo0000000000000000dkXXXXX│   │XXXXXXXcXM  MM       /     \   Xlo0000000000000000dk     │   │        MM  MOlXXXXXX/     \XXXXlo0000000000000000dk     │   │        MM
 mlOXXXX/       \XXX0:O00000000000000OdKXXXXX└───┘XXXXXXkoM    MM     /       \  X0:O00000000000000OdK     └───┘       MM    mlOXXXX/       \XXX0:O00000000000000OdK     └───┘       MM 
  Xc0XXXXXXXXXXXXXXXXxl0000000000000Oo0XXXXXXXXXXXXXXXXOcN      MM                 xl0000000000000Oo                  MM      Xc0XXXXXXXXXXXXXXXXxl0000000000000Oo                  MM  
   XlOXXXXXXXXXXXXXXXXdlO0000000000Od0XXXXXXXXXXXXXXXXxlN        MM                 dlO0000000000O                   MM        XlOXXXXXXXXXXXXXXXXdlO0000000000O                   MM   
    Wxd0XXXXXXXXXXXXXXXkldO000000Oxx0XXXXXXXXXXXXXXKkdkW          MM                 kldO000000Ox                   MM          Wxd0XXXXXXXXXXXXXXXkldO000000Ox                   MM    
     MNxdOKXXXXXXXXXXXXXKklok00kxx0XXXXXXXXXXXXXXKkdkWM            MM                 Kklok00kxK                   MM            MNxdOKXXXXXXXXXXXXXKklok00kxK                   MM     
      MMWOkxxkKXXXXXXXXXXXKx:lllOKXXXXXXXXXXK0kxxk0WMM              MM                 XKx::xKX                   MM              MMWOkxxkKXXXXXXXXXXXKx::xKX                   MM      
       MMMMMW0kkkxxxxxxxkkkONMMXOkkkxxxxxxxkkkKWMMMMM                MMMMMW0kkkxxxxxxxkkkONMMXOkkkxxxxxxxkkkKWMMMMM                MMMMMW0kkkxxxxxxxkkkONMMXOkkkxxxxxxxkkkKWMMMMM       



SQL – JOIN Statements
SELECT a.FIELD_1, ..., a.FIELD_N, b.FIELD_1, ..., b.FIELD_N
FROM TABLE_1 a
FULL OUTER JOIN TABLE_2 b
ON a.KEY = b.KEY;

SELECT a.FIELD_1, ..., a.FIELD_N, b.FIELD_1, ..., b.FIELD_N
FROM TABLE_1 a
INNER JOIN TABLE_2 b
ON a.KEY = b.KEY;

SELECT a.FIELD_1, ..., a.FIELD_N, b.FIELD_1, ..., b.FIELD_N
FROM TABLE_1 a
LEFT JOIN TABLE_2 b
ON a.KEY = b.KEY;



SQL – Identifying the JOIN field
┌────────────────┬─────────────┬─────────┬─────────┬───────┬──────────┐
│ Transaction_ID │ Customer_Id │ Channel │ Product │ Price │ Discount │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000123    │    60067    │   Web   │   Book  │  9.95 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000124    │    12345    │  Store  │   Book  │ 11.95 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000125    │    23451    │  Store  │   DVD   │ 14.95 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000126    │    70436    │ Reseller│   DVD   │ 19.95 │    5     │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000127    │    66772    │  Store  │ Magazine│  3.25 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000128    │    60067    │   Web   │   Book  │ 29.95 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000129    │    72045    │   Web   │   DVD   │  9.95 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000130    │    82371    │ Reseller│ Magazine│  2.5  │   0.25   │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000131    │    12345    │  Store  │   Book  │  7.95 │          │
└────────────────┴─────────────┴─────────┴─────────┴───────┴──────────┘

                                         TRANSACTIONS            PRODUCTS
┌─────────┬─────────────┬───────────┐ ┌────────────────┐       ┌──────────┐
│ Product │   Material  │   Medium  │ │ Transaction_ID │   ┌──►│  Product │
├─────────┼─────────────┼───────────┤ ├────────────────┤   │   ├──────────┤
│   Book  │ Stock Paper │   Visual  │ │   Customer_Id  │   │   │ Material │
├─────────┼─────────────┼───────────┤ ├────────────────┤   │   ├──────────┤
│   DVD   │   Plastic   │Audiovisual│ │     Channel    │   │   │  Medium  │
├─────────┼─────────────┼───────────┤ ├────────────────┤   │   └──────────┘
│ Magazine│ Glossy Paper│   Visual  │ │     Product    │◄──┘
├─────────┼─────────────┼───────────┤ ├────────────────┤
│    CD   │   Plastic   │   Audio   │ │      Price     │
├─────────┼─────────────┼───────────┤ ├────────────────┤
│Newspaper│   Newprint  │   Visual  │ │    Discount    │
├─────────┼─────────────┼───────────┤ └────────────────┘
│   MP3   │    Digital  │   Audio   │
└─────────┴─────────────┴───────────┘



SQL – JOIN Statements
Let’s say I want more information about the products that were actually purchased:
SELECT a.*, b.*
FROM TRANSACTIONS a
LEFT JOIN PRODUCTS b
ON a.PRODUCT = b.PRODUCT;

TRANSACTIONS
┌────────────────┬─────────────┬─────────┬─────────┬───────┬──────────┬──────────────┬────────┐
│ Transaction_ID │ Customer_Id │ Channel │ Product │ Price │ Discount │   Material   │ Medium │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┼──────────────┼────────┤
│     1000123    │    60067    │   Web   │   Book  │  9.95 │          │  Stock Paper │ Visual │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┼──────────────┼────────┤
│     1000124    │    12345    │  Store  │   Book  │ 11.95 │          │  Stock Paper │ Visual │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┼──────────────┼────────┤
│     1000125    │    23451    │  Store  │   DVD   │ 14.95 │          │ Plastic │ Audiovisual │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┼──────────────┼────────┤
│     1000126    │    70436    │ Reseller│   DVD   │ 19.95 │    5     │ Plastic │ Audiovisual │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┼──────────────┼────────┤
│     1000127    │    66772    │  Store  │ Magazine│  3.25 │          │ Glossy Paper │ Visual │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┼──────────────┼────────┤
│     1000128    │    60067    │   Web   │   Book  │ 29.95 │          │  Stock Paper │ Visual │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┼──────────────┼────────┤
│     1000129    │    72045    │   Web   │   DVD   │  9.95 │          │ Plastic │ Audiovisual │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┼──────────────┼────────┤
│     1000130    │    82371    │ Reseller│ Magazine│  2.5  │   0.25   │ Glossy Paper │ Visual │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┼──────────────┼────────┤
│     1000131    │    12345    │  Store  │   Book  │  7.95 │          │  Stock Paper │ Visual │
└────────────────┴─────────────┴─────────┴─────────┴───────┴──────────┴──────────────┴────────┘

Why not an INNER JOIN?
SELECT a.*, b.*
FROM TRANSACTIONS a
INNER JOIN PRODUCTS b
ON a.PRODUCT = b.PRODUCT;
• In this case, the query would actually return the same result
• However, if a product were missing from the PRODUCT table, those transactions would be eliminated
• Sometimes this is desirable, sometimes not, depending on the question you are trying to answer!

Why not a FULL OUTER JOIN?
SELECT a.*, b.*
FROM TRANSACTIONS a
FULL OUTER JOIN PRODUCTS b
ON a.PRODUCT = b.PRODUCT;
┌────────────────┬─────────────┬─────────┬─────────┬───────┬──────────┬──────────────┬────────┐
│ Transaction_ID │ Customer_Id │ Channel │ Product │ Price │ Discount │   Material   │ Medium │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┼──────────────┼────────┤
│     1000123    │    60067    │   Web   │   Book  │  9.95 │          │  Stock Paper │ Visual │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┼──────────────┼────────┤
│     1000124    │    12345    │  Store  │   Book  │ 11.95 │          │  Stock Paper │ Visual │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┼──────────────┼────────┤
│     1000125    │    23451    │  Store  │   DVD   │ 14.95 │          │ Plastic │ Audiovisual │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┼──────────────┼────────┤
│     1000126    │    70436    │ Reseller│   DVD   │ 19.95 │    5     │ Plastic │ Audiovisual │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┼──────────────┼────────┤
│     1000127    │    66772    │  Store  │ Magazine│  3.25 │          │ Glossy Paper │ Visual │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┼──────────────┼────────┤
│     1000128    │    60067    │   Web   │   Book  │ 29.95 │          │  Stock Paper │ Visual │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┼──────────────┼────────┤
│     1000129    │    72045    │   Web   │   DVD   │  9.95 │          │ Plastic │ Audiovisual │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┼──────────────┼────────┤
│     1000130    │    82371    │ Reseller│ Magazine│  2.5  │   0.25   │ Glossy Paper │ Visual │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┼──────────────┼────────┤
│     1000131    │    12345    │  Store  │   Book  │  7.95 │          │  Stock Paper │ Visual │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┼──────────────┼────────┤
│                │             │         │Newspaper│       │          │   Newprint   │ Visual │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┼──────────────┼────────┤
│                │             │         │   MP3   │       │          │    Digital   │  Audio │
└────────────────┴─────────────┴─────────┴─────────┴───────┴──────────┴──────────────┴────────┘



SQL – More JOINing Logic
<allSqlJoins>



SQL – JOIN Statements
Extended Example:
• Return average price of products by Medium
• Exclude Resellers
• Only include Medium values where average price > 10
• Sort results from highest to lowest average price

SELECT b.MEDIUM, AVG(a.PRICE) AS AVG_PRICE
FROM TRANSACTIONS a
LEFT JOIN PRODUCTS b
ON a.PRODUCT = b.PRODUCT
WHERE a.CHANNEL <> 'RESELLER'
GROUP BY b.MEDIUM
HAVING AVG_PRICE > 12.50
ORDER BY AVG_PRICE DESC;

┌───────────┬───────────┐
│ AVG_PRICE │   Medium  │
├───────────┼───────────┤
│   12.61   │   Visual  │
├───────────┼───────────┤
│   12.45   │Audiovisual│
└───────────┴───────────┘



SQL – The UNION Statement
The JOIN Statement effectively add ‘columns’ to a data set by joining tables left to right
The UNION Statement adds ‘rows’ to a data set by joining two tables or data sets that have exactly the same set of columns
SELECT FIELD_A, FIELD_B, FIELD_C
FROM TABLE_1
UNION
SELECT FIELD_D, FIELD_E, FIELD_F
FROM TABLE_2;
• The field names in the top and bottom SELECT statements do not have to be the same
• However, the data types in them DO have to be the same and in the same order, and there needs to be the same overall number of fields in both sets:
FIELD_A ~ FIELD_D	FIELD_B ~ FIELD_E	FIELD_C ~ FIELD_F

┌────────────────┬─────────────┬─────────┬─────────┬───────┬──────────┐
│ Transaction_ID │ Customer_Id │ Channel │ Product │ Price │ Discount │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000123    │    60067    │   Web   │   Book  │  9.95 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000124    │    12345    │  Store  │   Book  │ 11.95 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000125    │    23451    │  Store  │   DVD   │ 14.95 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000126    │    70436    │ Reseller│   DVD   │ 19.95 │    5     │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000127    │    66772    │  Store  │ Magazine│  3.25 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000128    │    60067    │   Web   │   Book  │ 29.95 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000129    │    72045    │   Web   │   DVD   │  9.95 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000130    │    82371    │ Reseller│ Magazine│  2.5  │   0.25   │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000131    │    12345    │  Store  │   Book  │  7.95 │          │
└────────────────┴─────────────┴─────────┴─────────┴───────┴──────────┘

Suppose my purchase information was actually stored in separate tables for each channel, and I wanted them all in one data set:
WEB_PURCHASE
┌────────────────┬─────────────┬─────────┬─────────┬───────┬──────────┐
│ Transaction_ID │ Customer_Id │ Channel │ Product │ Price │ Discount │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000123    │    60067    │   Web   │   Book  │  9.95 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000128    │    60067    │   Web   │   Book  │ 29.95 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000129    │    72045    │   Web   │   DVD   │  9.95 │          │
└────────────────┴─────────────┴─────────┴─────────┴───────┴──────────┘
STORE_PURCHASE
┌────────────────┬─────────────┬─────────┬─────────┬───────┬──────────┐
│     1000124    │    12345    │  Store  │   Book  │ 11.95 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000125    │    23451    │  Store  │   DVD   │ 14.95 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000127    │    66772    │  Store  │ Magazine│  3.25 │          │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000131    │    12345    │  Store  │   Book  │  7.95 │          │
└────────────────┴─────────────┴─────────┴─────────┴───────┴──────────┘
RESELLER_PURCHASE
┌────────────────┬─────────────┬─────────┬─────────┬───────┬──────────┐
│     1000126    │    70436    │ Reseller│   DVD   │ 19.95 │    5     │
├────────────────┼─────────────┼─────────┼─────────┼───────┼──────────┤
│     1000130    │    82371    │ Reseller│ Magazine│  2.5  │   0.25   │
└────────────────┴─────────────┴─────────┴─────────┴───────┴──────────┘

SELECT *, 'Web' AS Channel
FROM WEB_PURCHASE
UNION
SELECT *, 'Store' AS Channel
FROM STORE_PURCHASE
UNION
SELECT *, 'Reseller' AS Channel
FROM RESELLER_PURCHASE;
┌────────────────┬─────────────┬─────────┬───────┬──────────┬─────────┐
│ Transaction_ID │ Customer_Id │ Product │ Price │ Discount │ Channel │
├────────────────┼─────────────┼─────────┼───────┼──────────┼─────────┤
│     1000123    │    60067    │   Book  │  9.95 │          │   Web   │
├────────────────┼─────────────┼─────────┼───────┼──────────┼─────────┤
│     1000128    │    60067    │   Book  │ 29.95 │          │   Web   │
├────────────────┼─────────────┼─────────┼───────┼──────────┼─────────┤
│     1000129    │    72045    │   DVD   │  9.95 │          │   Web   │
├────────────────┼─────────────┼─────────┼───────┼──────────┼─────────┤
│     1000124    │    12345    │   Book  │ 11.95 │          │  Store  │
├────────────────┼─────────────┼─────────┼───────┼──────────┼─────────┤
│     1000125    │    23451    │   DVD   │ 14.95 │          │  Store  │
├────────────────┼─────────────┼─────────┼───────┼──────────┼─────────┤
│     1000127    │    66772    │ Magazine│  3.25 │          │  Store  │
├────────────────┼─────────────┼─────────┼───────┼──────────┼─────────┤
│     1000131    │    12345    │   Book  │  7.95 │          │  Store  │
├────────────────┼─────────────┼─────────┼───────┼──────────┼─────────┤
│     1000126    │    70436    │   DVD   │ 19.95 │    5     │ Reseller│
├────────────────┼─────────────┼─────────┼───────┼──────────┼─────────┤
│     1000130    │    82371    │ Magazine│  2.5  │   0.25   │ Reseller│
└────────────────┴─────────────┴─────────┴───────┴──────────┴─────────┘

SELECT Transaction_ID, Customer_ID, 'Web' AS Channel, Product,
Price, Discount
FROM WEB_PURCHASE
UNION
SELECT SELECT Transaction_ID, Customer_ID, 'Store' AS Channel,
Product, Price, Discount
FROM STORE_PURCHASE
UNION
SELECT SELECT Transaction_ID, Customer_ID, 'Reseller' AS Channel,
Product, Price, Discount
FROM RESELLER_PURCHASE
ORDER BY TRANSACTION_ID;












Hugo Días

https://www.eversql.com/sql-syntax-check-validator/

MÓDULO II

Un paciente puede hacer una cita al doctor, el doctor atiende en un consultorio, el cual es parte de un hospital. Un doctor tiene como jefe a otro doctor y puede tener una o varias especialidades médicas.

PASOS
1. Identificar entidades
a. Definir los atributos que describen cada entidad.
┌──────────────────┬─────────────────┬────────────────────┬─────────────────────┬──────────────────┬─────────────────────┬──────────────────────┐
│     PACIENTE     │       CITA      │       DOCTOR       │     CONSULTORIO     │     HOSPITAL     │         JEFE        │     ESPECIALIDAD     │
├──────────────────┼─────────────────┼────────────────────┼─────────────────────┼──────────────────┼─────────────────────┼──────────────────────┤
│id_paciente       │                 │                    │                     │                  │                     │                      │
│nombre            │fecha            │nombre              │no_consultorio       │nombre            │nombre               │                      │
│paterno           │                 │paterno             │                     │                  │                     │                      │
│materno           │                 │materno             │                     │                  │                     │                      │
│telefono          │hora             │                    │no_paciente          │direccion         │no_doctor_subordinado│                      │
│correo            │                 │                    │                     │                  │                     │                      │
│fecha_nacimiento  │consultorio      │                    │doctor_asignado      │telefono          │no_doctor            │                      │
│genero            │no_paciente      │cedula              │tipo_especialidad    │director          │area_asignada        │                      │
│                  │no_cita          │especialidad        │horario              │nivel             │tipo_especialidad    │                      │
│                  │doctor_asignado  │horario_trabajo     │no_hospital          │tipo_especialidad │                     │                      │
│                  │tipo_especialidad│telefono            │edificio             │                  │                     │                      │
│                  │no_hospital      │correo              │telefono             │                  │                     │                      │
│                  │diagnostico      │consultorio_asignado│jefe_del_doctor      │                  │                     │                      │
│                  │                 │jefe_doctor         │                     │                  │                     │                      │
│                  │                 │                    │                     │                  │                     │                      │
│                  │                 │                    │                     │                  │                     │                      │
│                  │                 │                    │                     │                  │                     │                      │
│                  │                 │                    │                     │                  │                     │                      │
└──────────────────┴─────────────────┴────────────────────┴─────────────────────┴──────────────────┴─────────────────────┴──────────────────────┘

2. Diseñar el modelo conceptual o grafo.
a. Restricciones de campo (PRIMARY KEY/FOREIGN KEY, NULL o NOT NULL, UNIQUE y CHECK)
b. Definición de los tipos de datos
---------------Independientes---------------
ESPECIALIDAD
id_especialidad: PRIMARY KEY (NOT NULL y UNIQUE), INT AUTO_INCREMENT
nombre: NOT NULL, VARCHAR(40)
---------------
DOMICILIO
id_domicilio: PRIMARY KEY (NOT NULL y UNIQUE), INT AUTO_INCREMENT
calle: NOT NULL, VARCHAR(60)
no_interior: NULL, VARCHAR(10)
no_exterior: NOT NULL, VARCHAR(10)
colonia: NOT NULL, VARCHAR(60)
cp: NOT NULL, VARCHAR(5)
---------------Dependientes---------------
PERSONA
id_persona: PRIMARY KEY (NOT NULL y UNIQUE), INT AUTO_INCREMENT
nombre: NOT NULL, VARCHAR(40)
paterno: NULL, VARCHAR(80)
materno: NULL, VARCHAR(80)
telefono: NOT NULL, VARCHAR(16)
correo: UNIQUE, NULL, VARCHAR(60)
fecha_nacimiento: NOT NULL, DATE
genero: NOT NULL, CHAR(1)
id_domicilio: FOREIGN KEY (REFERENCES DOMICILIO), INT
---------------
HOSPITAL
id_hospital: PRIMARY KEY (NOT NULL y UNIQUE), INT AUTO_INCREMENT
nombre: NOT NULL, VARCHAR(60)
telefono: NOT NULL, VARCHAR(16)
nivel: NOT NULL, CHAR(1)
id_domicilio: FOREIGN KEY (REFERENCES DOMICILIO), INT
---------------
PACIENTE
id_paciente: PRIMARY KEY (NOT NULL y UNIQUE), INT AUTO_INCREMENT
id_persona: FOREIGN KEY (REFERENCES PERSONA), INT
nss: UNIQUE, NULL, VARCHAR(20)
tipo_sangre: NULL, VARCHAR(4)
---------------
DOCTOR
id_doctor: PRIMARY KEY (NOT NULL y UNIQUE), INT AUTO_INCREMENT
id_persona: FOREIGN KEY (REFERENCES PERSONA), INT
cedula: UNIQUE, NOT NULL, VARCHAR(30)
id_jefe_doctor: FOREIGN KEY (REFERENCES DOCTOR), INT
---------------
CONSULTORIO
id_consultorio: PRIMARY KEY (NOT NULL y UNIQUE), INT AUTO_INCREMENT
id_hospital: FOREIGN KEY (REFERENCES HOSPITAL), INT
edificio: NOT NULL, VARCHAR(40)
piso: NOT NULL, CHAR(2)
telefono: NOT NULL, VARCHAR(16)
---------------
CITA
id_cita: PRIMARY KEY (NOT NULL y UNIQUE), INT AUTO_INCREMENT
fecha_hora: NOT NULL, TIMESTAMP
id_consultorio: FOREIGN KEY (REFERENCES CONSULTORIO), INT
id_paciente: FOREIGN KEY (REFERENCES PACIENTE), INT
id_doctor: FOREIGN KEY (REFERENCES DOCTOR), INT
---------------
DOCTOR_ESPECIALIDAD
id_doctor: PRIMARY KEY, FOREIGN KEY (REFERENCES DOCTOR), INT
id_especialidad: PRIMARY KEY, FOREIGN KEY (REFERENCES ESPECIALIDAD), INT

3. Crear el Modelo Entidad-Relación (DE-R)

X. Crear el SQL respectivo:
DROP DATABASE IF EXISTS Hospital;
CREATE DATABASE Hospital;
USE Hospital;
CREATE TABLE IF NOT EXISTS `Hospital`.`PERSONA` (
  `id_persona` INT NOT NULL AUTO_INCREMENT,
  `nombre` VARCHAR(40) NOT NULL,
  `paterno` VARCHAR(80) NULL,
  `materno` VARCHAR(80) NULL,
  `telefono` VARCHAR(16) NOT NULL,
  `correo` VARCHAR(60) NULL,
  `fecha_nacimiento` DATE NOT NULL,
  `genero` CHAR(1) NOT NULL,
  PRIMARY KEY (`id_persona`),
  UNIQUE INDEX `id_persona_UNIQUE` (`id_persona` ASC) VISIBLE, /*ASC: Ordenar ascendente*/
  UNIQUE INDEX `correo_UNIQUE` (`correo` ASC) VISIBLE);
CREATE TABLE IF NOT EXISTS `Hospital`.`HOSPITAL` (
  `id_hospital` INT NOT NULL AUTO_INCREMENT,
  `nombre` VARCHAR(60) NOT NULL,
  `telefono` VARCHAR(16) NOT NULL,
  `nivel` CHAR(1) NOT NULL,
  PRIMARY KEY (`id_hospital`),
  UNIQUE INDEX `id_hospital_UNIQUE` (`id_hospital` ASC) VISIBLE);
CREATE TABLE IF NOT EXISTS `Hospital`.`ESPECIALIDAD` (
  `id_especialidad` INT NOT NULL AUTO_INCREMENT,
  `nombre` VARCHAR(40) NOT NULL,
  PRIMARY KEY (`id_especialidad`),
  UNIQUE INDEX `id_especialidad_UNIQUE` (`id_especialidad` ASC) VISIBLE);
CREATE TABLE IF NOT EXISTS `Hospital`.`PACIENTE` (
  `id_paciente` INT NOT NULL AUTO_INCREMENT,
  `nss` VARCHAR(20) NULL,
  `tipo_sangre` VARCHAR(4) NULL,
  `id_persona` INT NOT NULL,
  PRIMARY KEY (`id_paciente`),
  UNIQUE INDEX `id_paciente_UNIQUE` (`id_paciente` ASC) VISIBLE,
  INDEX `fk_PACIENTE_PERSONA_idx` (`id_persona` ASC) VISIBLE,
  CONSTRAINT `fk_PACIENTE_PERSONA`
    FOREIGN KEY (`id_persona`)
    REFERENCES `Hospital`.`PERSONA` (`id_persona`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE);
CREATE TABLE IF NOT EXISTS `Hospital`.`DOCTOR` (
  `id_doctor` INT NOT NULL AUTO_INCREMENT,
  `cedula` VARCHAR(30) NULL,
  `id_jefe_doctor` INT NULL,
  `id_persona` INT NOT NULL,
  PRIMARY KEY (`id_doctor`),
  UNIQUE INDEX `id_doctor_UNIQUE` (`id_doctor` ASC) VISIBLE,
  UNIQUE INDEX `cedula_UNIQUE` (`cedula` ASC) VISIBLE,
  INDEX `fk_DOCTOR_DOCTOR1_idx` (`id_jefe_doctor` ASC) VISIBLE,
  INDEX `fk_DOCTOR_PERSONA1_idx` (`id_persona` ASC) VISIBLE,
  CONSTRAINT `fk_DOCTOR_DOCTOR1`
    FOREIGN KEY (`id_jefe_doctor`)
    REFERENCES `Hospital`.`DOCTOR` (`id_doctor`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `fk_DOCTOR_PERSONA1`
    FOREIGN KEY (`id_persona`)
    REFERENCES `Hospital`.`PERSONA` (`id_persona`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE);
CREATE TABLE IF NOT EXISTS `Hospital`.`CONSULTORIO` (
  `id_consultorio` INT NOT NULL AUTO_INCREMENT,
  `edificio` VARCHAR(40) NOT NULL,
  `piso` CHAR(2) NOT NULL,
  `telefono` VARCHAR(16) NOT NULL,
  `id_hospital` INT NOT NULL,
  PRIMARY KEY (`id_consultorio`),
  UNIQUE INDEX `id_consultorio_UNIQUE` (`id_consultorio` ASC) VISIBLE,
  INDEX `fk_CONSULTORIO_HOSPITAL1_idx` (`id_hospital` ASC) VISIBLE,
  CONSTRAINT `fk_CONSULTORIO_HOSPITAL1`
    FOREIGN KEY (`id_hospital`)
    REFERENCES `Hospital`.`HOSPITAL` (`id_hospital`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE);
CREATE TABLE IF NOT EXISTS `Hospital`.`CITA` (
  `id_cita` INT NOT NULL AUTO_INCREMENT,
  `fecha_hora` TIMESTAMP NOT NULL,
  `id_paciente` INT NOT NULL,
  `id_doctor` INT NOT NULL,
  `id_consultorio` INT NOT NULL,
  PRIMARY KEY (`id_cita`),
  UNIQUE INDEX `id_cita_UNIQUE` (`id_cita` ASC) VISIBLE,
  INDEX `fk_CITA_PACIENTE1_idx` (`id_paciente` ASC) VISIBLE,
  INDEX `fk_CITA_DOCTOR1_idx` (`id_doctor` ASC) VISIBLE,
  INDEX `fk_CITA_CONSULTORIO1_idx` (`id_consultorio` ASC) VISIBLE,
  CONSTRAINT `fk_CITA_PACIENTE1`
    FOREIGN KEY (`id_paciente`)
    REFERENCES `Hospital`.`PACIENTE` (`id_paciente`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `fk_CITA_DOCTOR1`
    FOREIGN KEY (`id_doctor`)
    REFERENCES `Hospital`.`DOCTOR` (`id_doctor`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `fk_CITA_CONSULTORIO1`
    FOREIGN KEY (`id_consultorio`)
    REFERENCES `Hospital`.`CONSULTORIO` (`id_consultorio`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE);
CREATE TABLE IF NOT EXISTS `Hospital`.`DOCTOR_ESPECIALIDAD` (
  `id_especialidad` INT NOT NULL,
  `id_doctor` INT NOT NULL,
  PRIMARY KEY (`id_especialidad`, `id_doctor`),
  INDEX `fk_DOCTOR_ESPECIALIDAD_DOCTOR1_idx` (`id_doctor` ASC) VISIBLE,
  CONSTRAINT `fk_DOCTOR_ESPECIALIDAD_ESPECIALIDAD1`
    FOREIGN KEY (`id_especialidad`)
    REFERENCES `Hospital`.`ESPECIALIDAD` (`id_especialidad`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `fk_DOCTOR_ESPECIALIDAD_DOCTOR1`
    FOREIGN KEY (`id_doctor`)
    REFERENCES `Hospital`.`DOCTOR` (`id_doctor`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE);

X+1. Reglas de negocio, modificadas:
-- UPDATE
CREATE TABLE IF NOT EXISTS `Hospital`.`DOMICILIO` (
  `id_domicilio` INT NOT NULL AUTO_INCREMENT,
  `calle` VARCHAR(60) NOT NULL,
  `no_interior` VARCHAR(10) NULL,
  `no_exterior` VARCHAR(10) NOT NULL,
  `colonia` VARCHAR(60) NOT NULL,
  `cp` VARCHAR(5) NOT NULL,
  PRIMARY KEY (`id_domicilio`),
  UNIQUE INDEX `id_domicilio_UNIQUE` (`id_domicilio` ASC) VISIBLE);
/*
	Pasos para modificar Tablas
    1. Agregar/borrar/modificar campos
    2. Agregar/borrar/modificar constraints
*/
ALTER TABLE `Hospital`.`PERSONA`
	ADD COLUMN id_domicilio INT NOT NULL,
	ADD CONSTRAINT chk_genero CHECK (genero = 'H' OR genero = 'M'),
    ADD CONSTRAINT fk_persona_domicilio FOREIGN KEY (`id_domicilio`)
		REFERENCES `Hospital`.`DOMICILIO` (`id_domicilio`)
		ON DELETE RESTRICT
		ON UPDATE CASCADE;
ALTER TABLE `Hospital`.`HOSPITAL`
	ADD COLUMN id_domicilio INT NOT NULL,
    ADD CONSTRAINT fk_hospital_domicilio FOREIGN KEY (`id_domicilio`)
		REFERENCES `Hospital`.`DOMICILIO` (`id_domicilio`)
		ON DELETE RESTRICT
		ON UPDATE CASCADE;

X+2. Manipular data:
-- DATA
DESCRIBE domicilio;
INSERT INTO domicilio(calle, no_interior, no_exterior, colonia, cp)
	VALUES ("Vergeles", null, "10-Bis", "Napoles", "02010");
INSERT INTO domicilio(calle, no_interior, no_exterior, colonia, cp)
	VALUES ("Emperadores", '3', '4', "Napoles", "03020"),
		("Uruguay", '9', '2', "Centro", "10010"),
		("Uxmal", '6', "11", "Narvarte", "04030"),
		("Miguel Angel de Quevedo", null, "70", "Coyoacan", "06080"),
		("Miguel Hidalgo", '2', "10", "Heores", "11000");
SELECT * FROM domicilio;
INSERT INTO persona(nombre, paterno, materno, telefono, correo, fecha_nacimiento, genero, id_domicilio)
	VALUES ("Ana", "Cerralde", "Torres", "59302089", "acerralde@yahoo.com", "1980-05-19", 'M', 1),
		("Roberto", "Gomez", "Ortiz", "51123456", "rgomez@hotmail.com", "1990-01-29", 'H', 2),
		("Ernesto", "Perez", "Ruiz", "58942345", "eperez@oracle.com", "1991-03-22", 'H', 3),
		("Guadalupe", "Islas", "Rojas", "56231224", "gislas@gmail.com", "1980-09-15", 'M', 4),
		("Synthia", "Fernandez", "Ostos", "57683685", "sfernandez@microsoft.com", "1989-02-22", 'M', 5),
		("Jorge", "Marquez", "Torres", "55123423", "jmarquez@ibm.com", "1975-11-11", 'H', 6);
SELECT * FROM persona;
INSERT INTO doctor(cedula, id_persona, id_jefe_doctor)
	VALUES ("111000", 1, null),
		("222000", 2, 1),
		("333000", 3, 2);
SELECT * FROM doctor;
INSERT INTO paciente(nss, tipo_sangre, id_persona)
	VALUES ("10A21", "0+", 4),
		("2SD34", "B-", 5),
		("56D3D", "B+", 6);
SELECT * FROM paciente;
INSERT INTO especialidad(nombre)
	VALUES ("Cardiologia"),
		("Gastroenterología"),
		("Infectología");
SELECT * FROM especialidad;
INSERT INTO doctor_especialidad(id_doctor, id_especialidad)
	VALUES (1,1), (1,3), (2,1), (2,2), (2,3),(3,3);
SELECT * FROM doctor_especialidad;
INSERT INTO hospital(nombre, telefono, nivel, id_domicilio)
	VALUES ("ABC", "54121232", '2', 2),
		("Angeles", "54351245", '1', 5);
SELECT * FROM hospital;
DESCRIBE consultorio;
SELECT * FROM consultorio;
INSERT INTO consultorio(edificio, piso, telefono, id_hospital)
	VALUES ("Torre Norte", '1', "45546456", 1),
		("Sur", "PB", "55464561", 2),
		("Norte", '2', "55242343", 1),
		("Este", '3', "55878644", 2);
SELECT * FROM consultorio;
DESCRIBE cita;
INSERT INTO cita(fecha_hora, id_paciente, id_consultorio, id_doctor)
	VALUES ("2022-10-05 16:30:00", 1, 2, 2),
		("2022-11-05 20:30:00", 2, 1, 1),
		("2022-11-10 18:00:00", 3, 3, 3),
		("2022-11-20 17:00:00", 2, 3, 3);
SELECT * FROM cita;

/*
	Buscar a las personas cuyo genero sea (H)ombre
	y el mes de nacimiento de MARZO
*/
SELECT * FROM persona
WHERE genero = 'H'
AND DATE_FORMAT(fecha_nacimiento, "%m") = 3;
/*
	Buscar a las personas cuyo año de nacimiento sea mayor
    o igual a 1990
*/
SELECT * FROM persona
WHERE DATE_FORMAT(fecha_nacimiento, "%Y") >= 1990;

-- Buscar a las personas cuyo nombre en la tercera tenga la 'a'
SELECT * FROM persona
WHERE nombre LIKE "__a%";
-- Con Expresiones Regulares
SELECT * FROM persona
WHERE nombre REGEXP 'e';

-- En Hospital nos piden agregar el campo de razon_social
ALTER TABLE hospital ADD COLUMN razon_social VARCHAR(100) NULL;
SELECT * FROM hospital;

SET SQL_SAFE_UPDATES = 0; -- Desactivar el modo seguro
UPDATE hospital SET razon_social = "Centro Medico ABC" WHERE id_hospital = 1;
UPDATE hospital SET razon_social = "Hospital Angeles S.A. de C.V." WHERE id_hospital = 2;
SELECT * FROM hospital;

-- Agregar en la tabla cita un estatus para saber si esta vigente o cancelada
ALTER TABLE cita ADD COLUMN estatus CHAR(1) NULL DEFAULT 'V';
SELECT * FROM cita;

-- Nos cancelan la cita del dia 2022-11-20 17:00:00
UPDATE cita SET estatus = 'C' WHERE fecha_hora = "2022-11-20 17:00:00";
SELECT * FROM cita;

-- Consultar el total de citas agendadas
SELECT COUNT(id_cita) AS "Total de citas" FROM cita; -- Mejor rendimiento
SELECT COUNT(1) AS "Total de citas" FROM cita; -- Es lo mismo que el anterior
SELECT COUNT(*) AS "Total de citas" FROM cita; -- Peor rendimiento

-- Consultar las citas que tiene cada doctor que son vigentes
SELECT COUNT(*) AS "Total de citas", P.nombre, P.paterno, P.materno
FROM cita C
JOIN doctor D ON C.id_doctor = D.id_doctor
JOIN persona P ON P.id_persona = D.id_persona
WHERE estatus = 'V'
GROUP BY P.nombre, P.paterno, P.materno;

-- Consultar de cada doctor sus especialidades
SELECT P.nombre, P.paterno, P.materno, E.nombre, D.cedula
FROM persona P
JOIN doctor D ON D.id_persona = P.id_persona
JOIN doctor_especialidad DE ON DE.id_doctor = D.id_doctor
JOIN especialidad E ON E.id_especialidad = DE.id_especialidad;

-- Consultar los nombres de los doctores y sus jefes sin importar si tiene jefe
SELECT P1.nombre, P1.paterno, P1.materno,
P2.nombre AS "Nombre jefe", P2.paterno "Apellido paterno jefe", P2.materno "Apellido materno jefe"
FROM doctor AS D1
JOIN persona P1 ON D1.id_persona = P1.id_persona
LEFT OUTER JOIN doctor D2 ON D1.id_jefe_doctor = D2.id_doctor
LEFT OUTER JOIN persona AS P2 ON P2.id_persona = D2.id_persona;

SELECT * FROM cita;

-- Borrar la(s) cita(s) cancelada(s)
DELETE FROM cita WHERE estatus = 'C';



Los "socios" de una __biblioteca__ solicitan el "prestamo" de "libros", de estos tienen varios ejemplares. Un libro es publicado por una "editorial" que tiene un /*pais*/. De los libros se necesitan conocen los "capitulos" y los "autores".
PASOS:
1. Identificar entidades
a. Definir los atributos que describen cada entidad.

SOCIO
	id_socio: PRIMARY KEY (NOT NULL y UNIQUE), INT AUTO_INCREMENT
	id_persona: FOREIGN KEY (REFERENCES PERSONA), INT
	estatus: NOT NULL, CHAR(2)
---------------
AUTOR
id_autor: PRIMARY KEY (NOT NULL y UNIQUE), INT AUTO_INCREMENT
id_persona: FOREIGN KEY (REFERENCES PERSONA), INT
---------------
	PERSONA
	id_persona: PRIMARY KEY (NOT NULL y UNIQUE), INT AUTO_INCREMENT
	nombre: NOT NULL, VARCHAR(40)
	paterno: NULL, VARCHAR(80)
	materno: NULL, VARCHAR(80)
	mail: UNIQUE, NULL, VARCHAR(60)
	telefono: NULL, VARCHAR(10)
---------------
EJEMPLAR
id_ejemplar: PRIMARY KEY (NOT NULL y UNIQUE), INT AUTO_INCREMENT
id_libro: FOREIGN KEY (REFERENCES LIBRO), INT
no_ejemplar --A2, C6, etc.
estatus
---------------
EDITORIAL
id_editorial: PRIMARY KEY (NOT NULL y UNIQUE), INT AUTO_INCREMENT
nombre:
id_pais: FOREIGN KEY (REFERENCES PAIS), INT
---------------
	PAIS
	id_pais: PRIMARY KEY (NOT NULL y UNIQUE), INT AUTO_INCREMENT
	nombre: NOT NULL, VARCHAR(30)
---------------
LIBRO
id_libro: PRIMARY KEY (NOT NULL y UNIQUE), INT AUTO_INCREMENT
titulo
anio
id_editorial: FOREIGN KEY (REFERENCES EDITORIAL), INT
---------------
LIBRO_AUTOR
id_libro: FOREIGN KEY (REFERENCES LIBRO), INT
id_autor: FOREIGN KEY (REFERENCES AUTOR), INT
---------------
PRESTAMO
id_prestamo: PRIMARY KEY (NOT NULL y UNIQUE), INT AUTO_INCREMENT
id_ejemplar: FOREIGN KEY (REFERENCES EJEMPLAR), INT
id_socio: FOREIGN KEY (REFERENCES SOCIO), INT
fecha_entrega
fecha_prestamo
fecha_devolucion
---------------
	CAPITULO
	id_capitulo: PRIMARY KEY (NOT NULL y UNIQUE), INT AUTO_INCREMENT
	titulo: NOT NULL, VARCHAR(30)
	no_capitulo: NOT NULL, VARCHAR(10)
---------------
LIBRO_CAPITULO
id_libro: FOREIGN KEY (REFERENCES LIBRO), INT
id_capitulo: FOREIGN KEY (REFERENCES CAPITULO), INT
---------------Independientes---------------
---------------Dependientes---------------


2. Diseñar el modelo conceptual o grafo.
a. Restricciones/integridad de campo. (PRIMARY KEY/FOREIGN KEY, NULL o NOT NULL, UNIQUE y CHECK)
b. Definición de los tipos de datos.

3. Crear el modelo Entidad-Relación (DE-R)












Loreli

MÓDULO III
PROGRAMACIÓN DE CONSULTAS DE BASES DE DATOS
1. Restricción de renglones
1.1. Operadores
1.1.1 De búsqueda
1.1.2 Lógicos
1.1.3 Operación con nulos
1.1.4 Agregados del estándar SQL 92
1.1.4.1 IN y NOT IN
1.1.4.2 BETWEEN y NOT BETWEEN
1.1.5 Operadores de cadenas

2. Ordenamiento

3. Consultas de varias tablas
3.1. Operaciones de álgebra relacional
3.1.1 Unión
3.1.2 Intersección
3.1.3. Diferencia
3.1.4. Junta de tablas
3.1.4.1 Cross join
3.1.4.2 Inner join
3.1.4.3 Outer join
3.1.4.4 Self join

7. Consultas de agrupamiento
7.1. Funciones de agregado
7.2. Restringiendo grupos con HAVING
7.3. Cálculos entre grupos

5. Instrucción CASE WHEN

6. Sub-consultas

4. Cálculo relacional
4.1. Uso de operadores EXISTS, ANY, SOME Y ALL

8. Operadores avanzados

9. Plan de ejecución de consultas

10. Creación de vistas

11. Consultas especializadas


lorelizn@gmail.com
IDEF1X

Herramientas Case de BD
* Draw.io
* Visio
* Workbench
* Lucidchart

Saturacion es el numero de repeticion de Valores en un dominio.

Tipos de datos: Primitivos (Codd), Estandar (ISO) y Propio del manejador.

SQL2 (1992)
Caracter: CHAR, VARCHAR, TEXT (limitado, mas de 255 caracteres, no se puede usar funciones de texto [como UPPER, LOWER, buscar])
	CodigoPostal (5 bytes): 09180
		VARCHAR: 5 bytes + 2 bytes --Variable + 2
		CHAR: 5 bytes --Fijo
			Para longitudes fijas: RFC, PLACAS, NUMEROS DE TELEFONOS, CP
			CP que sea un CHAR con un Constraint de Check que sea digito
Tiempos: DATE, TIME, TIMESTAMP (para tablas historicas, por ejemplo los Diccionarios de Datos del Manejador), DATETIME (ISO [cualquier manejador lo maneja], no usar porque no tiene su RFC [no es estandar])
Numericos: NUMERIC (usable), DECIMAL (flotante)
	NO USAR: INT, INTERGER, SMALLINT, BIGINT, TINYINT/Bool/Boolean... (Son propios de los Manejadores)

	Enteros: NUMERIC(<enteros>,<decimales>)
		NUMERIC(6,0): -999,999 a +999,999
			edad: NUMERIC(3,0) CONSTRAINT ckAlumnoEdad CHECK (edad BETWEEN 18 AND 40)
	Decimales: NUMERIC(<enteros>,<decimales>)
		NUMERIC(4,2): -99.99 a +99.99
			FLOAT, DECIMAL, MONEY, CURRENCY... (Propios de los Manejadores)
Todos los datos no Numeros, llevan ''.

CREATE TABLE persona (
	idPersona NUMERIC(2,0) NOT NULL, -- -99 a +99 y utilizar un CHECK para solo usar los positivos
	cp CHAR(5),
	nombre VARCHAR(30), -- +2
	edad NUMERIC(3,0), --Esto es un chiste
	anioNacimiento NUMERIC(4,0), --Utilizar este, porque no todo el tiempo vas a tener 26 años
	fechaRegistro DATE,
	CONSTRAINT pkPersona PRIMARY KEY (idPersona),
	CONSTRAINT ckPkPersona CHECK (idPersona >= 1)
);

NOT NULL: Es obligado o que si o si debe tener un dato, o en cristiano significa que en el INSERT no puede faltar.
NULL: Opcional, el complemento de NOT NULL o su opuesto. Puede ser nulo.

DBMS (Todos e incluyendo al Relacional, no necesariamente es un relacional).
RDBMS (Los relacionales)
	Cliente (Software el más común/Hardware) - Servidor (Maquina, fierros)
		CLI/Comando: psql
		GUI: pgAdmin
		TOA: SuperSoftware de una empresa.
	Una varias BD de sistema (tablas de sistema/diccionarios de datos db):
		PostgreSQL: postgresql
		SqlServer: model, master, mdb, temp
		Pueden ser metadatos, usuarios, permisos, etc.
OOBMS (Los orientados a objetos)



Server [localhost]:
Database [postgres]:
Port [5432]:
Username [postgres]:
Contraseña para usuario postgres:
psql (14.2)
ADVERTENCIA: El código de página de la consola (850) difiere del código
            de página de Windows (1252).
            Los caracteres de 8 bits pueden funcionar incorrectamente.
            Vea la página de referencia de psql «Notes for Windows users»
            para obtener más detalles.
Digite «help» para obtener ayuda.

postgres=# CREATE DATABASE empleados;
ERROR:  la base de datos «empleados» ya existe
postgres=# DROP DATABASE empleados;
DROP DATABASE
postgres=# CREATE DATABASE empleados;
CREATE DATABASE
postgres=# \c empleados
Ahora está conectado a la base de datos «empleados» con el usuario «postgres».
empleados=# 

Primitivos: Caracter, Tiempo, Numero

Como se escribe:
SELECT
FROM
	[WHERE]
		<>!=
		() AND OR
		BETWEEN
		IN
		IS NULL
		LIKE
	[GROUP BY]
		[HAVING]
			[AND|OR]
	[ORDER BY];
      VS
Como se ejecuta:
5.SELECT
1.FROM
	2.[WHERE]
		2.1.[AND|OR]
	3.[GROUP BY]
		3.1.[HAVING]
			3.1.1.[AND|OR]
	4.[ORDER BY];

Restriccion (operador del algebra relacional), WHERE
	Busqueda 89 (SQL1)
		>	Numeros y Tiempos
		<	Numeros y Tiempos
		>=	Numeros y Tiempos
		<=	Numeros y Tiempos
		=	Todos tipos datos
		!=	Todos tipos datos
		(<>), NO estandar

		SELECT * FROM empleado WHERE contratacion > '2000-01-01';
		SELECT * FROM empleado WHERE edad > 18;
		SELECT * FROM empleado WHERE tipoSangre = '+B' ;
		SELECT * FROM empleado WHERE tipoSangre != '+0' ;
	Logicos 89 (SQL1)
		()
		AND
		OR

		Matemáticas:
		+ -
		x /
		^ raiz
		derivada integral
		()
		----------
		X+3/2(5*5) = X+3/2(25) = X+3/2(25) =  X+3/2*25 =
			X+1.5(25) = X+37.5

		WHERE a=1 AND b=2 OR c=3 --89, v1
			WHERE true OR noImporta
			WHERE false OR true
			es igual a
		WHERE (a=1 AND b=2) OR c=3 --89, v1

		WHERE a=1 OR b=2 AND c=3
			es igual a
		WHERE a=1 OR (b=2 AND c=3) --Mucha crema a los tacos xD

		WHERE (a=1 OR b=2) AND c=3

		WHERE (a=1 OR b=2) AND c=3 OR (d=4 OR (e=5 OR f=6)) AND g=3;

		-- Mostrar el nombre y la edad de los empleados mujeres que no sean del departamento 4 o los empleados hombres que ganen 20,000 o sean del cargo 3.
		SELECT nombre, edad
		FROM empleado
			WHERE sexo = 'M' AND iddepartamento != 4
				OR sexo = 'H'
				AND (sueldo = 20000 OR idcargo = 3);
		------------------
		SELECT nombre, edad FROM empleado WHERE sexo = 'M' AND iddepartamento != 4 OR sexo = 'H' AND (sueldo = 20000 OR idcargo = 3);
		-- Mostrar a los empleados que siendo del cargo mayor a 3 ESTEN o por porcentaje de comision 3 o con sueldo menor a 15,000. Independiente cualquier empleado llamado Juan que sea González.
		SELECT *
		FROM empleado
		WHERE idcargo > 3
			AND (porcentaje_comision = 3 OR sueldo < 15000)
			OR nombre = 'Juan' AND paterno = 'González';
		------------------
		SELECT * FROM empleado WHERE idcargo > 3 AND (porcentaje_comision = 3 OR sueldo < 15000) OR nombre = 'Juan' AND paterno = 'González';

		Traza de consulta: Es la forma en que se ejecuta (con recursos Cpu y Ram), mediante el manejador, la consulta de manera mas efectiva.
		Ruta critica: Tiempo (no es un recurso ya que no se recupera, es un costo), recursos y costo.

		GROUP BY
			Saturacion es el numero de repeticion de Valores
				Alta: Genero
				Bajo: Id, UNIQUE
			El GROUP BY es valido para la alta Saturacion (muchos valores diferentes).
			No es valido si en el SELECT ya solo devuelve un solo dato o muchos valores iguales.
			No es valido si no se hacen operaciones en el SELECT:
				SELECT sexo FROM empleado GROUP BY sexo;
				SELECT DISTINCT sexo FROM empleado; --Sacar los grupos de valores diferentes de un dominio. O devuelve valores distintos.

			Mostrar el promedio de los sueldos: SELECT AVG(sueldo) AS promedioSueldo FROM empleado GROUP BY iddepartamento;
			Mostrar POR departamento el promedio del sueldo: SELECT iddepartamento, AVG(sueldo) AS promedioSueldo FROM empleado GROUP BY iddepartamento;
			Mostrar POR edad el sueldo mas grande: SELECT edad, MAX(sueldo) AS maxSueldo FROM empleado GROUP BY edad;
			Mostrar POR sexo y edad el sueldo mas grande: SELECT edad, sexo, MAX(sueldo) AS maxSueldo FROM empleado GROUP BY edad, sexo;
			Mostrar POR departamento y sexo el sueldo mas grande: SELECT iddepartamento, sexo, MAX(sueldo) AS maxSueldo FROM empleado GROUP BY iddepartamento, sexo;
				No hay un grupo de mujeres que no tengan un departamento.
			Cuantos hombres y mujeres hay por departamento: SELECT iddepartamento, sexo, MAX(sueldo) AS maxSueldo, COUNT(*) AS contenoGeneroDepartamento FROM empleado GROUP BY iddepartamento, sexo;
			Los vendedores (por genero) que tienen departamento: SELECT iddepartamento, sexo, MAX(sueldo) AS maxSueldo, COUNT(*) AS contenoGeneroDepartamento, COUNT(porcentaje_comision) AS noVendedores FROM empleado GROUP BY iddepartamento, sexo;
			Regla: COUNT debe aceptar valores nulos para que valga la pena contabilizarlo si no se contabiliza con *.
			SELECT iddepartamento, sexo, AVG(sueldo) AS promedioSueldo, COUNT(*) AS contenoGeneroDepartamento, COUNT(porcentaje_comision) AS noVendedores FROM empleado WHERE paterno LIKE '%o' AND materno LIKE '%o' GROUP BY iddepartamento, sexo;
			5. SELECT iddepartamento,
				sexo,
				AVG(sueldo) AS promedioSueldo,
				COUNT(*) AS contenoGeneroDepartamento,
				COUNT(porcentaje_comision) AS noVendedores
			1. FROM empleado
			2. WHERE paterno LIKE '%o'
			3. AND materno LIKE '%o'
			4. GROUP BY iddepartamento, sexo;
			Mostrar el sueldo mas grande y el ultimo contratado POR cargo y edad de los empleados mujeres que no sean vendedoras.
				SELECT MAX(sueldo),
					MIN(contratacion),
					idcargo,
					edad
				FROM empleado
				WHERE porcentaje_comision IS NULL
					AND sexo = 'M'
				GROUP BY idcargo,
					edad;
			Mostrar POR apellidos, cuántos empleados hay que tengan un cargo del 1 al 3 o un sueldo mayor a 15,000:
				SELECT paterno,
					materno,
					COUNT(*) AS conteoEmpleados
				FROM empleado
				WHERE idcargo BETWEEN 1 AND 3
					OR sueldo > 15000
				GROUP BY paterno, materno;
				-- Pero en este caso como paterno y materno tienen valores diferentes Y como la restricción de sueldo complementa la restricción de cargo:
				SELECT paterno, materno FROM empleado;

			funcionesDeAgregadoOAgrupado + => 1
				No hacen agrupamiento, SOLO un RESUMEN del atribuo.
				Campo/atributo calculado no tiene nombre, para ello se le asigna un Alias.
			COUNT	Todos tipos datos
				Cuantos hay de un grupo, no incluyen los nulos.
				Cuantos empleados hay: SELECT COUNT(*) FROM empleado;
				Cuantos paternos hay: SELECT COUNT(paterno) FROM empleado;
				Cuantos porcentaje_comision hay: SELECT COUNT(porcentaje_comision) FROM empleado;
				Cuantos iddepartamento hay: SELECT COUNT(iddepartamento) FROM empleado;
			MAX		Todos tipos datos
				Numéros		mayor
				Fechas		--- hoy +++
				Caracter	Z o código ascii grande
					SELECT MAX(edad), MAX(contratacion), MAX(nombre) FROM empleado;
					ERROR, No estandar: SELECT MAX(edad) maximaEdad FROM empleado;
					ERROR, por el espacio, baja rendimiento: SELECT MAX(edad) AS "Maxima Edad" FROM empleado;
					VALIDO: SELECT MAX(edad) AS maximaEdad FROM empleado;
					VALIDO, pero el S.O. puede no tener bien configurado el teclado: SELECT MAX(edad) AS maxima_edad FROM empleado;
			MIN		Todos tipos datos
				Numéros		menor
				Fechas		--- hoy +++
				Caracter	a o código ascii pequeño
					SELECT MIN(edad), MIN(contratacion), MIN(nombre) FROM empleado;
					ERROR, No estandar: SELECT MIN(edad) maximaEdad FROM empleado;
					ERROR, por el espacio, baja rendimiento: SELECT MIN(edad) AS "Maxima Edad" FROM empleado;
					VALIDO: SELECT MIN(edad) AS maximaEdad FROM empleado;
					VALIDO, pero el S.O. puede no tener bien configurado el teclado: SELECT MIN(edad) AS maxima_edad FROM empleado;
			AVG		Numeros
				SELECT AVG(sueldo) AS promedioSueldo FROM empleado;
			SUM		Numeros
				SELECT SUM(sueldo) AS sumaSueldo FROM empleado;

			HAVING
				Restricción de agrupamiento/agregado:
					Que la ultima fecha de contratacion no sea en el 2000:
						HAVING MAX(contratacion) NOT BETWEEN '01-01-2000' AND '31-12-2000'
				Restricción simple (de la tabla):
					Que la fecha de contratacion no sea en el 2000:
						WHERE contratacion NOT BETWEEN '01-01-2000' AND '31-12-2000'

				HAVING MAX(edad) != 50
				WHERE edad != 50
				--
				HAVING AVG(sueldo) BETWEEN
				--
				HAVING MAX(nombre) IN ('Valencia', 'Toño')
				WHERE nombre IN ('Valencia', 'Toño')

				SELECT sexo,
					COUNT(*) AS conteoEmpleados
				FROM empleado
				WHERE MAX(contratacion) != '02-02-2000'
				GROUP BY sexo; -- no se permiten funciones de agregación en WHERE

				SELECT sexo,
					COUNT(*) AS conteoEmpleados
				FROM empleado
				GROUP BY sexo
				HAVING contratacion != '02-02-2000'; -- la columna «empleado.contratacion» debe aparecer en la cláusula GROUP BY o ser usada en una función de agregación

				Mostrar POR cargo el sueldo más grande de los que fueron contratados al ÚLTIMO en un año diferente de 2000 y que su edad promedio sea arriba de 35, contando que si es mujer tenga un cargo diferente del 1.
				SELECT idcargo, MAX(sueldo)
				FROM empleado
				WHERE sexo = 'M'
					AND idcargo != 1
				GROUP BY idcargo
					HAVING AVG(edad) > 35
					AND MAX(contratacion) NOT BETWEEN '01-01-2000' AND '31-12-2000';

				Si es hombre que no tenga una 'o' en su nombre y que su sueldo sea diferente de 50,500. Si es mujer que gane menos de 20,000 siendo del departamento 1, 3 y 5. Independientemente todos su suma de sueldos debe ser 30,000 o 45,000 o 45,500 o mayor a 60,000. Mostrando POR edad cuántos hay con departamento y su ÚLTIMA fecha de contratacion.
				SELECT edad,
					COUNT(iddepartamento) AS conteoDepartamento,
					MIN(contratacion) AS ultimaFechaContratacion
				FROM empleado
				WHERE sexo = 'H'
				AND nombre NOT LIKE '%o%'
				AND sueldo != 50500
				OR sexo = 'M'
				AND sueldo < 20000
				AND iddepartamento IN (1, 3, 5)
				GROUP BY edad
					HAVING SUM(sueldo) IN (30000, 45000, 45500)
					OR SUM(sueldo) > 60000;
		ORDER BY <atributo> [ASC|DESC][, ...] -- Solo sirve para verse bonito
			SELECT * --Esto NO es Proyección
			FROM empleado
			ORDER BY 2 DESC, 1 ASC; -- Mal uso

			SELECT *
			FROM empleado
			ORDER BY nombre DESC, idempleado ASC; -- Buen uso

			SELECT *
			FROM empleado
			ORDER BY edad; -- Mal uso

			SELECT *
			FROM empleado
			ORDER BY edad ASC; -- Buen uso

			SELECT edad, sueldo, nombre --Esto SI es Proyección
			FROM empleado
			ORDER BY nombre DESC, idempleado ASC;

		SELECT * -- No hace una Proyección
		SELECT atributo -- Hace una Proyección
	Relacionales (SQL 89 + SQL 92)
		BETWEEN	Numéros y Tiempos
			SELECT *
			FROM empleado
				WHERE sueldo >= 15000
					AND sueldo <= 35000;
			Son lo mismo en resultado pero el rendimiento es mayor el de abajo.
			SELECT *
			FROM empleado
				WHERE sueldo BETWEEN 15000
					AND 35000;
			Los empleados nacidos en el segundo siglo despues de Cristo:
			SELECT contratacion
			FROM empleado
				WHERE contratacion BETWEEN '2000-01-01'
					AND '3000-01-01';
			El complemento del anterior:
			SELECT contratacion
			FROM empleado
				WHERE contratacion NOT BETWEEN '2000-01-01'
					AND '3000-01-01';
		IN	Todos tipos datos
			SELECT *
			FROM empleado
				WHERE nombre = 'Liliana'
				OR nombre = 'Oscar'
				OR nombre = 'Arturo';
			Son lo mismo en resultado pero el rendimiento es mayor el de abajo.
			SELECT *
			FROM empleado
				WHERE nombre IN ('Liliana', 'Oscar', 'Arturo');
			El complemento del anterior:
			SELECT *
			FROM empleado
				WHERE nombre NOT IN ('Liliana', 'Oscar', 'Arturo');

			Numero:
			SELECT *
			FROM empleado
				WHERE edad NOT IN (18,20,35);

			Fecha/tiempo:
			SELECT *
			FROM empleado
				WHERE contratacion IN ('1989-12-01','1989-04-30','1994-03-20');
		IS NULL	Todos tipos datos
			SELECT *
			FROM empleado
				WHERE porcentaje_comision = NULL;
			No son lo mismo, ya que al mostrar el conjunto vacio, no se muestra nada, precisamente.
			SELECT *
			FROM empleado
				WHERE porcentaje_comision IS NULL;
			El complemento del anterior:
			SELECT *
			FROM empleado
				WHERE porcentaje_comision IS NOT NULL;
		LIKE	Caracter --Patrones de SQL, NO REGEX (Expresiones Regulares)
			SELECT *
			FROM empleado
				WHERE nombre = 'Ana'; -- 89
			No son lo mismo, ya que el LIKE es como un Regex, pero funciona diferente, otro tipo de patrones.
			SELECT *
			FROM empleado
				WHERE nombre LIKE '%na%'; -- 92
				_	1 caracter obligatorio
					SELECT *
					FROM empleado
						WHERE nombre LIKE '__t___';
				%	cualquier posible(s) caracter(es), o sea de 0 a n cantidad
					SELECT * FROM empleado WHERE nombre LIKE '__t%';
				[]	Rango
				^	Complemento del rango del []


			Oracle y PostgreSQL funcionan con Regex (cuales cambian entre si) y depreca los corchetes: ^.*(r|t)..$
				SELECT *
				FROM empleado
					WHERE nombre LIKE '__[t,T]___'; --La 't' o la 'T'
				SELECT *
				FROM empleado
					WHERE nombre LIKE '__t___' OR nombre LIKE '__T___';

			SELECT * FROM empleado WHERE nombre LIKE 'A%a';
			Entre el inicio y el final, sea 'a':
			SELECT * FROM empleado WHERE nombre LIKE '_%a%_';

			Nombre que antepenultima letra en r o en t.
				SELECT * FROM empleado WHERE nombre LIKE '%r__' OR nombre LIKE '%t__';
				Oracle y PostgreSQL funcionan con Regex (cuales cambian entre si) y depreca los corchetes: ^.*(r|t)..$
					SELECT * FROM empleado WHERE nombre LIKE '%[r,t]__'; -- 'r' o 't'
			Nombre que antepenultima letra sea de la 'c' a la 'l'.
				SELECT * FROM empleado WHERE nombre LIKE '%[c-l]__'; -- De la 'c' a la 'l'. O sea 'c' o 'd' o 'e' o 'f' ... 'l'
			'[A-L]%_a%[o,a,r,s]'
				VALE:
					A lond ra     s
					L il   ia n   a
					A le   ja ndr a
					H o    ra ci  o
				NO VALE: Lauisana
					Para que fuera esta, tendria que ser la siguiente: '[A-L]_%_a%[o,a,r,s]'
						Probar en SqlServer:
						DECLARE @nombre VARCHAR(8)
						SET @nombre='Lauisana'
						SELECT @nombre WHERE @nombre LIKE '[A-L]_%_a%[o,a,r,s]';
			Cualquier parte del nombre completo donde termine con vocal.
				SELECT * FROM empleado WHERE nombre LIKE '%_[a,e,i,o,u]' OR paterno LIKE '%_[a,e,i,o,u]' OR materno LIKE '%_[a,e,i,o,u]';

		Mostrar/dame/devuelve(me)/regresame el nombre,edad,sueldo del empleado
		Que el empleado tenga un departamento.
		Que los apellidoS sean Gonzalez, Reyes o Sanchez.
		Ademas que el nombre de las mujeres no termine en 'a' y no tengan porcentaje_comision
		O el nombre de los hombres no termine en 'o' y su sueldo sea entre 15 mil y 30 mil.
		SELECT nombre,edad,sueldo
		FROM empleado
		WHERE iddepartamento IS NOT NULL
			AND paterno IN ('Gonzalez', 'Reyes', 'Sanchez')
			AND materno IN ('Gonzalez', 'Reyes', 'Sanchez')
			AND (sexo = 'M'
				AND nombre NOT LIKE '%_a'
				AND porcentaje_comision IS NULL
				OR sexo = 'H'
				AND nombre NOT LIKE '%_o'
				AND sueldo BETWEEN 15000 AND 30000
			);

	Todos los WHERE son Restricciones
	Pero no todas las Restricciones son WHERE.

	El complemento de WHERE es el HAVING, que también es una restricción xD.

https://stackoverflow.com/questions/1565234/character-with-encoding-utf8-has-no-equivalent-in-win1252


Tipos de Tablas: https://es.wikipedia.org/wiki/Tabla_(base_de_datos)
Tablas Persistentes: Son aquellas que permiten que los registros sean eliminados o borrados manualmente y se clasifican en tres tipos.
	Base: Es donde se encuentra toda la información de todos los registros sin que se haga ninguna validación adicional.
		Empresa Jodidita
		Corporación: MierdCrosoft,Apple,Google,Indra,Spotify,Amazon
		Particionamiento: Una tabla de partición es una tabla especial que se divide en segmentos, denominados particiones, que facilitan la administración y la consulta de tus datos. Dividir una tabla grande en particiones más pequeñas puede mejorar el rendimiento de la consulta.
			Las unicas tablas que se particionan son las base, y se almacenan en otra BD y otro dispositivo de almacenamiento.
		https://cloud.google.com/bigquery/docs/partitioned-tables?hl=es-419#:~:text=Una%20tabla%20de%20partici%C3%B3n%20es,el%20rendimiento%20de%20la%20consulta.
		Distribución de carga.
			Jack El Destripador xD
			El Divide y venceras :D
	Vista: Es una relación que se hace en referencia a una fila o columna específica.
		Una vista existe cuando se ejecuta, crea una tabla temporal.
		Lo que la mayoria entiende:
			SELECT *
			FROM empleado
				WHERE sueldo >= 15000
					AND sueldo <= 35000;
		Lo que ADEMÁS es:
			CREATE VIEW superLibros
			AS
				SELECT titulo,autor,cantidad
				FROM libros
				WHERE idcodigolibro >3;
		Todo en el modelo relacional, son relaciones.
	Instantáneo: Es todo registro que se puede ver de manera inmediata con solo una referencia.
		Una instantánea de base de datos es una vista estática de solo lectura de una base de datos de SQL Server (la base de datos de origen). La instantánea de base de datos es coherente en cuanto a las transacciones con la base de datos de origen tal como existía en el momento de la creación de la instantánea. Una instantánea de base de datos siempre reside en la misma instancia de servidor que la base de datos de origen. Aunque las instantáneas de base de datos proporcionan una vista de solo lectura de los datos que se encuentran en el mismo estado que cuando se creó la instantánea, el tamaño del archivo de instantáneas crece a medida que se realizan cambios en la base de datos de origen.
		https://learn.microsoft.com/es-es/sql/relational-databases/databases/database-snapshots-sql-server?view=sql-server-ver16
Tablas Temporales: Son aquellas tablas que son eliminadas automáticamente por el motor de base de datos o múltiples dispositivos.

Supertipos y subtipos
Supertipo - Un tipo de entidad que se relaciona con uno o más subtipos.
Subtipo - Un subgrupo de entidades con atributos únicos.
Legado - El concepto de que las entidades de subtipos heredan los valores de todos los atributos del supertipo.
https://www.lucidchart.com/pages/es/diagrama-entidad-relacion-extendido#:~:text=Supertipo%20-%20Un%20tipo%20de%20entidad,todos%20los%20atributos%20del%20supertipo.
Supertipo:
	MATERIAL: idMaterial, titulo
Subtipo:
	VIDEO: idVideo, duracion, formato, idMaterial
	LIBRO: idLibro, numPag, idMaterial
https://slideplayer.es/slide/3356552/11/images/2/Supertipos+y+Subtipos+Supertipo+MATERIAL+#id+*t%C3%ADtulo+VIDEO+*duraci%C3%B3n.jpg

Pedido-PedidoCancela (Supertipo-Subtipo)

No hay recursiva, entonces que hay?
Tablas Binarias (son las que tiene dos relaciones de los mismos dos dominios y las mismas llaves), Ternarias

ON DELETE/UPDATE RESTRICT/CASCADE
En una relación de base de datos, puede haber una tabla padre y una tabla hija, donde la tabla hija tiene una clave externa que hace referencia a la clave primaria de la tabla padre. Cuando ocurre una acción de eliminación o actualización en la tabla padre, las opciones "ON DELETE" y "ON UPDATE" determinan cómo se manejarán los registros relacionados en la tabla hija.

Aquí están las opciones más comunes para "ON DELETE" y "ON UPDATE":
1. RESTRICT: Esto impide la eliminación o actualización de un registro en la tabla padre si hay registros relacionados en la tabla hija. Es decir, si se intenta eliminar o actualizar un registro en la tabla padre que tiene registros relacionados en la tabla hija, se generará un error y la operación no se llevará a cabo.
2. CASCADE: Esta opción permite la eliminación o actualización en cascada, lo que significa que si se elimina o actualiza un registro en la tabla padre, los registros relacionados en la tabla hija también se eliminarán o actualizarán automáticamente. En otras palabras, la eliminación o actualización en la tabla padre se propaga a la tabla hija.
3. SET NULL: Con esta opción, si se elimina o actualiza un registro en la tabla padre, la clave externa correspondiente en la tabla hija se establece en NULL. Esto significa que los registros relacionados en la tabla hija todavía existen, pero su referencia al registro padre se pierde.
4. SET DEFAULT: Similar a "SET NULL", esta opción establece la clave externa correspondiente en la tabla hija en un valor predeterminado definido por el usuario en lugar de NULL. Esto implica que si se elimina o actualiza un registro en la tabla padre, la clave externa en la tabla hija se establece en un valor predeterminado.

Es importante tener cuidado al utilizar las opciones "CASCADE", "SET NULL" y "SET DEFAULT", ya que pueden tener un impacto significativo en la integridad y consistencia de los datos en la base de datos. Se debe tener una comprensión clara de las relaciones y dependencias entre las tablas antes de usar estas opciones.

CONSTRAINT pkPedido
PRIMARY KEY (idPedido)

CONSTRAINT fkPedidoJefe
FOREIGN KEY (idJefe)
REFERENCES vendedor(idVend)
ON DELETE RESTRICT
ON UPDATE CASCADE

CONSTRAINT fkPedidoVend
FOREIGN KEY (idVend)
REFERENCES vendedor(idVend)
ON DELETE RESTRICT
ON UPDATE CASCADE

Perfomance and Tuning/Rendimiento y mejora:
	No usar el autoincremental.

TAREA 2
Esto solo sirve para Access, FoxPro y Lotus, que tienen la licencia Office de Microsoft. Y viene reemplazando las '':
WHERE fecha = #2-02-2000#

Sql (1) 89 hace busquedas lentas.
Sql (2) 92 hace busquedas rapidas.
	Cood agregó funciones de agregado y operadores.
		WHERE edad >= 25 AND edad <= 50
		WHERE edad BETWEEN 25 AND 50
		--
		WHERE edad = 21 AND edad = 30
		AND edad = 45 AND edad = 50
		WHERE edad = 21 OR edad = 30
		OR edad = 45 OR edad = 50
		WHERE edad IN (21, 30, 45, 50)
		--
		WHERE edad = NULL
		WHERE edad IS NULL
		--



		WHERE fecha LIKE '0_-01-2000' --Esto solo es valido, SI fecha NO es de tipo DATE y en cambio es de tipo VARCHAR(10)
		Pero si se desea utilizar funciones de agregado/agrupado, mejor utilza HAVING.
			AVG --Promedio
			COUNT --Contar todo lo indicado
			SUM --Sumar todo lo indicado
			MAX --Todos los tipos de datos
				Numeros
				Tiempos: O el mas reciente
				Texto: De acuerdo al valor ascii.
			MIN
				Numeros
				Tiempos: O el mas viejo
				Texto: De acuerdo al valor ascii.

		SELECT contratacion
		FROM empleado
		GROUP BY contratacion
			HAVING CAST(contratacion AS VARCHAR(10)) LIKE '2000-01-0_';

		SELECT *
		FROM empleado
		GROUP BY contratacion
			HAVING CAST(contratacion AS VARCHAR(10)) LIKE '2000-01-0_'; --ERROR:  column "empleado.idempleado" must appear in the GROUP BY clause or be used in an aggregate function

		SELECT nombre,contratacion
		FROM empleado
		GROUP BY edad,nombre,contratacion
			HAVING CAST(contratacion AS VARCHAR(10)) LIKE '2000-01-__';

		SELECT sueldo,contratacion
		FROM empleado
		GROUP BY sueldo,contratacion
			HAVING CAST(contratacion AS VARCHAR(10)) LIKE '2000-01-__'
				AND MAX(sueldo) >= 0.00;

		https://learn.microsoft.com/en-us/sql/t-sql/functions/cast-and-convert-transact-sql?view=sql-server-ver16
		--
		En los Relacionales el "NOT" es el complemento, NO el "negado", ya que no existe ese concepto en los BDR:
			[NOT] BETWEEN
			IS [NOT] NULL
			[NOT] LIKE
				'r[a-o]%'
				'r[^a-o]%'
			[NOT] IN

convert implicit data postgresql site:postgresql.org + pgAdmin


Algebra Relacional: Modelo relacional, SQL 92

SQL 99 (sql1 + sql2 + dboo)
- Teoria de conjuntos
- Lógica de predicados

MariaBD, MongoBD, etc. Son modelos hibridos.
Algebra Relacional es la forma de manipular los datos (conjunto de operaciones), hacia las Relaciones (tablas) y el SELECT.

Conjuntos:
	UNIÓN (UNION, ∪): Combina las tuplas (VALORES) en común de ambos dominios.
	INTERSECCION (INTERSECT, ∩): Muestra las tuplas (VALORES) que esten en común de ambas tablas (relaciones) a operar.
	DIFERENCIA (EXCEPT, -): Muestra las tuplas (VALORES) que esten en la primer tabla a operar pero no en la segunda.
	PRODUCTO CARTESIANO (CROSS JOIN, Χ): El resultado de tomar la primer tupla de la primer relación y combinarla con todos y cada una de las tuplas de la segunda relación, continuando con la segunda tupla y asi sucesivamente hasta terminar con la primer tupla.

Relacionales:
	RESTRICCIÓN (WHERE, HAVING, σ)
	PROYECCIÓN (SELECT, π, Pi): Operación que altera el grado o el orden del grado de una relación.
	JOIN (JOIN, ⋈): Operación (compuesta: PRODUCTO CARTESIANO + RESTRICCIÓN) que junta las tuplas de dos relaciones mediante el atributo en común (que es del mismo tipo de dato o mapeable, entre dos tablas y que las referencía).
	DIVISIÓN (÷): Se utiliza para encontrar registros en una tabla que estén relacionados con todos los valores de otra tabla.

SELECT * FROM <tabla>; -- Es la unica que no utiliza el algebra relacional. Porque muestra absolutamente todo.

Operaciones de Conjuntos
	UNIÓN	(∪)
		1. El encabezado del resultado siempre es el encabezado de la primer tabla a operar.
			SELECT * FROM cargo
			UNION
			SELECT * FROM departamento;
			idcargo, nombre, iddepartamento, nombre. => idcargo, nombre
		2. Grado y cardinalidad: El numero de atributos/columnas deben ser del mismo grado, de las dos tablas a operar.
			-- Sintaxis
			SELECT [*|atributo,...]
			FROM <tabla>
			UNION
			SELECT [*|atributo,...]
			FROM <tabla>;
			-- Unión simple
			SELECT * FROM cargo
			UNION
			SELECT * FROM departamento;
			Cargo (2): idcargo, nombre.
			Departamento (2): iddepartamento, nombre.
			-- Una unión compuesta
			SELECT * FROM cargo
			UNION
			SELECT idEmpleado, nombre FROM empleado;
			-- Ejemplo
			A = {1,2,3}
			B = {2,3,7,8}
			A U B = {1,2,3,7,8}

			La unión sirve para el balanceo de carga, ya que una tabla puede ser enorme, y para ello se divide en pequeñas tablas.
			-- Elimina valores repetidos (teniendo en cuenta que los valores son toda la tupla/registro/renglon/fila)
			SELECT idcargo
			FROM cargo
			UNION
			SELECT iddepartamento
			FROM departamento;
			-- No elimina valores repetidos, y sirve para la auditoria, para comprobar que sigan existiendo.
			SELECT idcargo
			FROM cargo
			UNION ALL
			SELECT iddepartamento
			FROM departamento;
			CUANTAS operaciones del algebra relacional se ocupan? 3

			SELECT *
			FROM cargo
			UNION
			SELECT *
			FROM empleado; --ERROR:  cada consulta UNION debe tener el mismo número de columnas

			SELECT nombre
			FROM cargo
			UNION
			SELECT porcentaje_comision
			FROM empleado; --ERROR:  los tipos character varying y numeric no son coincidentes en UNION
		3. Los grados correspondientes deben ser del mismo tipo o mapeables. Un "tipo CAST" implicito.
			SELECT nombre
			FROM cargo
			UNION
			SELECT sexo
			FROM empleado;

			SELECT sexo
			FROM empleado
			UNION
			SELECT nombre
			FROM cargo;

			O sea que el sexo que es un texto de 1 caracter (CHAR(1)) y el nombre que es un texto de 255 caracteres (VARCHAR(255)), sexo cabe dentro del nombre. O sea sus valores pueden ser un subconjunto del otro, dentro de la vista generada.
			sexo ⊆ nombre

			SELECT nombre
			FROM cargo
			WHERE nombre NOT LIKE '%a'
			UNION
			SELECT sexo
			FROM empleado;
			CUANTAS operaciones del algebra relacional se ocupan? 4
			CUALES operaciones del algebra relacional se ocupan? PROYECCIÓN, RESTRICCIÓN Y UNIÓN

	UNIÓN	(∪*): Union all does not remove duplicate, to both tables.
			SELECT nombre
			FROM cargo
			UNION ALL
			SELECT sexo
			FROM empleado;


			SELECT sexo
			FROM empleado
			UNION
			SELECT sexo
			FROM empleado;

			SELECT sexo
			FROM empleado
			UNION ALL
			SELECT sexo
			FROM empleado;

	INTERSECCION	(∩)
		1. El encabezado de resultado siempre es el encabezado de la primer tabla a operar.
		2. Grado y cardinalidad: El numero de atributos: Deben ser del mismo grado, las dos tablas a operar.
		3. Los grados correspondientes deben ser del mismo tipo o mapeables. Un "tipo CAST" implicito.
			-- Sintaxis
			SELECT [*|atributo,...]
			FROM <tabla>
			INTERSECT
			SELECT [*|atributo,...]
			FROM <tabla>;
			-- Ejemplo
			A = {1,2,3}
			B = {2,3,7,8}
			A ∩ B = {2,3}
			SELECT * FROM cargo
			INTERSECT
			SELECT * FROM departamento;

			SELECT idcargo FROM cargo
			INTERSECT
			SELECT iddepartamento FROM departamento;

	INTERSECCION	(∩*): Intersect all does not remove duplicate, to both tables.
		1. El encabezado del resultado siempre es el encabezado de la primer tabla a operar.
		2. Grado y cardinalidad: El numero de atributos/columnas deben ser del mismo grado, las dos tablas a operar.
		3. Los grados correspondientes deben ser del mismo tipo o mapeables. Un "tipo CAST" implicito.
			-- Sintaxis
			SELECT [*|atributo,...]
			FROM <tabla>
			INTERSECT ALL
			SELECT [*|atributo,...]
			FROM <tabla>;

			-- Ejemplo
			A = {1,2,3}
			B = {2,3,7,8}
			A ∩ B = {2,3}

			SELECT * FROM cargo
			INTERSECT ALL
			SELECT * FROM departamento;

			SELECT * FROM departamento
			INTERSECT
			SELECT * FROM departamento;

			SELECT * FROM departamento
			INTERSECT ALL
			SELECT * FROM departamento;

			SELECT idcargo FROM cargo
			INTERSECT ALL
			SELECT iddepartamento FROM departamento;
			https://www.datasciencemadesimple.com/intersect-and-intersect-all-in-postgresql/
			---------------------

			idcargo	nombre
			1		A
			1		B
			2		C
			2		D

			idepto	nombre
			1		A
			1		E
			2		C
			3		D

			SELECT idcargo FROM cargo
			INTERSECT ALL
			SELECT iddepartamento FROM departamento;
			idcargo -- Con proyección
			1
			1
			2

			SELECT * FROM cargo
			INTERSECT ALL
			SELECT * FROM departamento;
			idcargo	nombre -- Sin proyección
			1		A
			2		C

	DIFERENCIA	(-)
		1. El encabezado de resultado siempre es el encabezado de la primer tabla a operar.
		2. Grado y cardinalidad: El numero de atributos/columnas deben ser del mismo grado, las dos tablas a operar.
		3. Los grados correspondientes deben ser del mismo tipo o mapeables. Un "tipo CAST" implicito.
			-- Sintaxis
			SELECT [*|atributo,...]
			FROM <tabla>
			EXCEPT|[MINUS] --El 1ro es estandar SQL2 (92), el 2do no lo es
			SELECT [*|atributo,...]
			FROM <tabla>;

			Casi el 50% de RDBMS utilizan EXCEPT y el casi otro 50% MINUS. xD

			-- Ejemplo
			A = {1,2,3}
			B = {2,3,7,8}
			A - B = {1}
			B - A = {7,8}

			SELECT * FROM cargo
			EXCEPT
			SELECT * FROM departamento;
			/*
				Es como si fuera esto:
				15 - 0 = 15
			*/

			SELECT idcargo FROM cargo
			EXCEPT
			SELECT iddepartamento FROM departamento;

			-- Ejemplo
			A = {1,9,1,2,3}
			B = {2,3,7,8}
			A -* B = {1,9,1}
			A - B = {1,9}
			B - A = {7,8}

			-- EJEMPLO BUENISIMO!!!!!!!!!!!!!!!!!!!
			A = {1,9,1,2,3}
			B = {2,3,7,8,1,10,10,9}
			A - B = {ǿ} --DUDA: si es {ǿ} o es el {1}
				Todo A contiene lo mismo que B.
			A -* B = {ǿ}
				Todo A contiene lo mismo que B.
			B - A = {7,8,10}
				Todo A contiene casi lo mismo que B.
				Pero los elementos que no estan en A, se conservan (de B).
				Y no hay repetición.
			B -* A = {7,8,10,10}
				Todo A contiene casi lo mismo que B.
				Pero los elementos que no estan en A, se conservan (de B).
				Y hay repetición.

			SELECT * FROM cargo
			EXCEPT ALL
			SELECT * FROM departamento;

			SELECT idcargo FROM cargo
			EXCEPT ALL
			SELECT iddepartamento FROM departamento;

	Ejecicios:
		Mostrar que cargos no han sido asignados a ningún empleado. UNION, INTERSECT e EXCEPT
		SELECT idcargo
		FROM cargo
		EXCEPT
		SELECT idEmpleado
		FROM empleado;

		Mostrar los apellidoS de las mujeres que no sean apellidoS de hombres, considerando que siempre esten en un cargo 1, 3 y 6.
		(SELECT paterno
			FROM empleado
			WHERE sexo = 'M' AND idcargo IN (1,3,6)
			UNION
			SELECT materno
			FROM empleado
			WHERE sexo = 'M' AND idcargo IN (1,3,6))
		EXCEPT
		(SELECT paterno
			FROM empleado
			WHERE sexo = 'H' AND idcargo IN (1,3,6)
			UNION
			SELECT materno
			FROM empleado
			WHERE sexo = 'H' AND idcargo IN (1,3,6));


		Mostrar las direcciones de Mexico que se llamen igual a las direcciones de Peru y el codigo postal sea 10925 o 10930 o 10927.
			CREATE DATABASE proyecto;
			\c proyecto;
			CREATE TABLE factura (
				idFactura numeric(2,0) NOT NULL,
				empresa varchar(45) NULL,
				nombre varchar(45) NOT NULL,
				dniRuc varchar(45) NOT NULL,
				direccion varchar(45) NOT NULL,
				direccion2 varchar(45) NULL,
				codigoPostal numeric(5,0) NOT NULL,
				ciudad varchar(45) NOT NULL,
				pais varchar(45) NOT NULL,
				infoAdicional varchar(45) NULL,
				telefonoFijo varchar(45) NOT NULL,
				telefonoMovil varchar(45) NOT NULL,
				CONSTRAINT pkFactura PRIMARY KEY (idFactura)
			);
			(SELECT direccion
			FROM factura
			WHERE pais = 'Mexico' AND codigoPostal IN (10925, 10930, 10927)
			UNION
			SELECT direccion2
			FROM factura
			WHERE pais = 'Mexico' AND codigoPostal IN (10925, 10930, 10927))
			INTERSECT
			(SELECT direccion
			FROM factura
			WHERE pais = 'Peru' AND codigoPostal IN (10925, 10930, 10927)
			UNION
			SELECT direccion2
			FROM factura
			WHERE pais = 'Peru' AND codigoPostal IN (10925, 10930, 10927));

	PRODUCTO CARTESIANO (Χ): El resultado de tomar la primer tupla de la primer relación y combinarla con todos y cada una de las tuplas de la segunda relación, continuando con la segunda tupla y asi sucesivamente hasta terminar con la primer tupla.
		El CROSS JOIN, NO ES un JOIN.
		1. El encabezado es igual a la suma del encabezado de la primer relación con la segunda tabla.
			idcargo nombre
			iddepartamento nombre
			===================
			idcargo nombre iddepartamento nombre
		2. El grado (total atributos) del resultado es igual a la suma de grados de ambas tablas.
			R(n) = 2 + 2 = 4

			idcargo nombre
			iddepartamento nombre
			===================
			idcargo nombre iddepartamento nombre
		3. La cardinalidad (total tuplas) del resultado es igual al producto de las cardinalidades de ambas tablas.
			R(n) = 6 * 6 = 36

			R1
			1
			2
			3

			R2
			1
			2

			CROSS JOIN
			1
			2
			3
			4
			5
			6

		SQL 92 - Cood
		SELECT *
		FROM <tablaA> CROSS JOIN <tablaB> [...];

		ISO
		SELECT *
		FROM <tablaA>, <tablaB> [...];

		SELECT sueldo -- MALO, porque consulta en los Diccionarios de datos
		FROM departamento CROSS JOIN empleado;

		SELECT empleado.sueldo -- BUENO, debe tener bien definido el contexto del atributo
		FROM departamento CROSS JOIN empleado;

			SELECT *
			FROM cargo CROSS JOIN departamento;

			SELECT *
			FROM cargo CROSS JOIN empleado;

			SELECT COUNT(*)
			FROM cargo CROSS JOIN departamento
				CROSS JOIN empleado;

			SELECT *
			FROM cargo CROSS JOIN departamento
				CROSS JOIN empleado;

Operaciones Relacionales
	RESTRICCIÓN (σ):
		WHERE and HAVING

	PROYECCIÓN (π, Pi): Operación que altera el grado o el orden del grado de una relación.
		SELECT iddepartamento, sueldo
		FROM empleado;

		SELECT nombre, idcargo
		FROM cargo;

	JOIN (⋈): Operación compuesta: (PRODUCTO CARTESIANO + RESTRICCIÓN) que junta las tuplas de dos relaciones mediante el atributo en común (que es del mismo tipo de dato o mapeable, entre dos tablas y que las referencía).
		* Operación compuesta: PRODUCTO CARTESIANO + RESTRICCIÓN
		* Restricción: Atributo común idóneo/referencia
		* Referencia: Trigger de integridad referencial y los CONSTRAINT Pk y Fk
			Trigger es un guardian de una tabla, espera a un DML (INSERT, UPDATE, DELETE)
		* Atributo común: Atributo con mismo tipo de dato o mapeable

		SELECT *
		FROM <tablaA> INNER JOIN <tablaB>
			ON (<tablaA>.<atributo> = <tablaB>.<atributo>);

		cargo			departamento
		cargo.idcargo	departamento.iddepartamento
		cargo.nombre	departamento.nombre

		El '.' es el operador de extensión/miembro/añadido.

		Atributo común
			cargo.idcargo = departamento.iddepartamento
			cargo.nombre = departamento.nombre

		Atributo común idóneo (refencia)
			cargo.idcargo = departamento.iddepartamento

		SELECT *
		FROM cargo INNER JOIN departamento
			ON(cargo.idcargo = departamento.iddepartamento); --Si ejecuta, si es join, no deberia hacerse
		SELECT *
		FROM cargo INNER JOIN departamento
			ON(cargo.nombre = departamento.nombre); --Si ejecuta, si es join, no deberia hacerse, ademas porque no tiene referencia

		SELECT *
		FROM cargo CROSS JOIN departamento;


		SELECT empleado.nombre, cargo.nombre, departamento.nombre
		FROM departamento INNER JOIN empleado
			ON(departamento.iddepartamento = empleado.iddepartamento)
				INNER JOIN cargo ON (cargo.idcargo = empleado.idcargo); --Siempre que haya un JOIN, se tiene que partir desde la que tiene las referencias hacias las otras tablas directas.
		departamento <-> empleado <-> cargo

		SELECT COUNT(*)
		FROM departamento AS d INNER JOIN empleado AS e
			ON(d.iddepartamento = e.iddepartamento)
				INNER JOIN cargo AS c ON (c.idcargo = e.idcargo); --Si o si tiene que calcular sus 684 registros Y con las Restricciones, se reduce a simplemente 17 registros.

		SELECT e.nombre, c.*, d.nombre
		FROM departamento AS d INNER JOIN empleado AS e
			ON(d.iddepartamento = e.iddepartamento)
				INNER JOIN cargo AS c ON (c.idcargo = e.idcargo);

		Regla para los Aliases:
		Al nombrarlos, siempre utilizar como maximo, 3 letras.
		Si no, simplemente utilizar su nombre original.

		Diagrama de Interrelaciones
			A <-> B <-> C              => (A,B,C) o (C,B,A)
			  <-> D <-> E              => (A,D,E) o (E,D,A)
			        <-> F              => (A,D,F) o (F,D,A)
			(A,C) --No hacer esto, porque necesito a B, para interrelacionarlos.
			Si quiero sacar los atributos que esten relacionados entre varias tablas.
			A <-> B <-> C
			A <-> B = X
			      X <-> C

		El JOIN idóneo/directo: Donde hay una referencia
			JOIN: (B,C)
			JOIN: (A,B)
			JOIN: (C,E)
			JOIN: (D,F)
		El JOIN NO idóneo/indirecto: Donde NO hay una referencia, por eso MODIFICARLO a directo
			JOIN: (C,E) => (C,B,A,D,E)
			JOIN: (E,B) => (E,D,A,B)
			JOIN: (F,B) => (F,D,A,B)
			JOIN: (A,F)   =[idóneo/Válido]=> (A,D,F)
			JOIN: (C,A,F) =[idóneo/Válido]=> (C,B,A,D,F)

		JOIN = Producto Cartesiano (CROSS JOIN) + Restricción = INNER JOIN
		CROSS JOIN: Tomar todos los valores del registro (renglon) y combinarlos con los valores de la otra tabla.
		Restricción: Del resultado anterior, filtrar aquellos donde el valor de un atributo de la primera tabla, es igual al valor del atributo de la otra tabla.

		Tipos de JOIN:
			Joins Internos: Que el atributo en común sea el mismo valor
				INNER JOIN
				SELF JOIN
				NATURAL JOIN
			Joins Externos (INNER + extra) --Darle prioridad (rescatar los valores que fueron expulsados por la restricción) a la izquierda/derecha/ambos
				RIGHT OUTER JOIN --Estandar 92
				RIGHT JOIN --No estandar
				LEFT OUTER JOIN --Estandar 92
				LEFT JOIN --No estandar
				FULL OUTER JOIN --Estandar ISO
				FULL: LEFT + RIGHT --Estandar 92
			https://donnierock.files.wordpress.com/2014/03/udqpd.jpg

			                      FULL OUTER JOIN                                                  INNER JOIN                                                 LEFT (OUTER) JOIN
			        MMMMMMWKOkkkkkkkOKNMMMMMMN0OkkkkkkkOXWMMMMMM                  MMMMMMWKOkkkkkkkOKNMMMMMMN0OkkkkkkkOXWMMMMMM                  MMMMMMWKOkkkkkkkOKNMMMMMMN0OkkkkkkkOXWMMMMMM        
			      MMMMXkxxdxOKKXXXKKOxdxxxxxxdkOKXXXXK0OxxxxONMMMM              MMM                 dxxxxxxd                 MMM              MMMMXkxxdxOKKXXXKKOxdxxxxxxd                 MMM      
			     MMXkxx0XXXXXXXXXXXXXKkdodxxk0KXXXXXXXXXXXXKOxxOWMM            MM                  Kkdodxxk0K                  MM            MMXkxx0XXXXXXXXXXXXXKkdodxxk0K                  MM     
			    MNddKXXXXXXXXXXXXXXKxld00000OxxOXXXXXXXXXXXXXXXOoxWM          MM                  xld00000OxxO                  MM          MNddKXXXXXXXXXXXXXXKxld00000OxxO                  MM    
			   Wko0XXXXXXXXXXXXXXXOld000000000OxkKXXXXXXXXXXXXXXXOoOM        MM                  ld000000000Oxk                  MM        Wko0XXXXXXXXXXXXXXXOld000000000Oxk                  MM   
			  WoxXXXXXXXXXXXXXXXX0cO000000000000kdKXXXXXXXXXXXXXXXKdxM      MM                  cO000000000000kd                  MM      WoxXXXXXXXXXXXXXXXX0cO000000000000kd                  MM  
			 MddXXXXXXXXXXXXXXXXKcx00000000000000xxXXXXXXXXXXXXXXXXKlkM    MM                  cx00000000000000xx                  MM    MddXXXXXXXXXXXXXXXXKcx00000000000000xx                  MM 
			MKcKXXXXXXXXAXXXXXXXdc0000000000000000o0XXXXX┌───┐XXXXXXKcWM  MM          A      Xdc0000000000000000o0     ┌───┐        MM  MKcKXXXXXXXXAXXXXXXXdc0000000000000000o0     ┌───┐        MM
			MdoXXXXXXXX/ \KXXXXXcd0000000000000000xxXXXXX│   │XXXXXXXc0M  MM         / \     Xcd0000000000000000xx     │   │        MM  MdoXXXXXXXX/ \KXXXXXcd0000000000000000xx     │   │        MM
			ModXXXXXXX/   \XXXXX:x0000000000000000xdXXXXX├───┤XXXXXXXlOM  MM        /   \    X:x0000000000000000xd     ├───┤        MM  ModXXXXXXX/   \XXXXX:x0000000000000000xd     ├───┤        MM
			MOlXXXXXX/     \XXXXlo0000000000000000dkXXXXX│   │XXXXXXXcXM  MM       /     \   Xlo0000000000000000dk     │   │        MM  MOlXXXXXX/     \XXXXlo0000000000000000dk     │   │        MM
			 mlOXXXX/       \XXX0:O00000000000000OdKXXXXX└───┘XXXXXXkoM    MM     /       \  X0:O00000000000000OdK     └───┘       MM    mlOXXXX/       \XXX0:O00000000000000OdK     └───┘       MM 
			  Xc0XXXXXXXXXXXXXXXXxl0000000000000Oo0XXXXXXXXXXXXXXXXOcN      MM                 xl0000000000000Oo                  MM      Xc0XXXXXXXXXXXXXXXXxl0000000000000Oo                  MM  
			   XlOXXXXXXXXXXXXXXXXdlO0000000000Od0XXXXXXXXXXXXXXXXxlN        MM                 dlO0000000000O                   MM        XlOXXXXXXXXXXXXXXXXdlO0000000000O                   MM   
			    Wxd0XXXXXXXXXXXXXXXkldO000000Oxx0XXXXXXXXXXXXXXKkdkW          MM                 kldO000000Ox                   MM          Wxd0XXXXXXXXXXXXXXXkldO000000Ox                   MM    
			     MNxdOKXXXXXXXXXXXXXKklok00kxx0XXXXXXXXXXXXXXKkdkWM            MM                 Kklok00kxK                   MM            MNxdOKXXXXXXXXXXXXXKklok00kxK                   MM     
			      MMWOkxxkKXXXXXXXXXXXKx:lllOKXXXXXXXXXXK0kxxk0WMM              MM                 XKx::xKX                   MM              MMWOkxxkKXXXXXXXXXXXKx::xKX                   MM      
			       MMMMMW0kkkxxxxxxxkkkONMMXOkkkxxxxxxxkkkKWMMMMM                MMMMMW0kkkxxxxxxxkkkONMMXOkkkxxxxxxxkkkKWMMMMM                MMMMMW0kkkxxxxxxxkkkONMMXOkkkxxxxxxxkkkKWMMMMM       

		El CROSS JOIN solo es un PRODUCTO CARTESIANO, NO TIENE RESTRICCIÓN.

		Los 2 estandares del JOIN
		JOIN con SQL2 (92) --Eficiente
			SELECT <atributo>
			FROM <tablaA> INNER JOIN <tablaB>
				ON (<tablaA>.<atributo> = <tablaB>.<atributo>);
		JOIN con ISO --Muy ineficiente, o tener muchos recursos o herramientas graficas (porque las hacen automaticamente)
			SELECT <atributo>
			FROM <tablaA>, <tablaB>
			WHERE <tablaA>.<atributo> = <tablaB>.<atributo>;

		Regla de ORO:
			Programación: Entre menos código mejor.
			SQL: Entre más código mejor, porque le doy al manejador más información/contexto, y no tendrá que deducir (consultar en las tablas del sistema), tomarse su tiempo, etc. Y por lo tanto será mucho más rápida la consulta.

		SELECT *
		FROM empleado AS e INNER JOIN cargo AS c
			ON(e.idCargo = c.idCargo);

		SELECT *
		FROM empleado AS e INNER JOIN departamento AS d
			ON(e.iddepartamento = d.iddepartamento);

		SELECT *
		FROM empleado AS e RIGHT OUTER JOIN departamento AS d
			ON(e.iddepartamento = d.iddepartamento);

		SELECT *
		FROM empleado AS e FULL OUTER JOIN departamento AS d
			ON(e.iddepartamento = c.iddepartamento);

		Mostrar a las mujeres que no teniendo departamento y todos los departamentos solo si ganan más de 25,000.
		SELECT *
		FROM empleado AS e FULL OUTER JOIN departamento
			ON(e.idDepartamento = departamento.idDepartamento)
		WHERE e.sexo = 'M'
		AND e.sueldo > 25000
		AND e.iddepartamento IS NULL
		OR e.sexo IS NULL;

		Mostrar el nombre del cargo y cuántos empleados mujeres hay por ese cargo, que su edad promedio esté entre 15 y 35, ordenando de manera descendente por el nombre del cargo el resultado.
		SELECT c.nombre, COUNT(*) AS totalEmpleadosMujeres
		FROM cargo AS c INNER JOIN empleado AS e
			ON (c.idCargo=e.idCargo)
		WHERE e.sexo = 'M'
		GROUP BY c.nombre
			HAVING AVG(e.edad) BETWEEN 15 AND 35
		ORDER BY c.nombre DESC;

		7+5+6 => 12+6 = 18
		A+B+C
		Incorrecto: A JOIN C JOIN B
		Correcto:
			A JOIN B JOIN C
			C JOIN B JOIN A
			B JOIN A JOIN C --Porque "B JOIN A" ya tiene a "B", entonces se puede con "C"
			B JOIN C JOIN A --Porque "B JOIN C" ya tiene a "B", entonces se puede con "A"

		A <-> B <-> C
		  <-> D <-> E
		        <-> F

		SELECT *
		FROM A INNER JOIN B
			ON(A.idA = B.idA)
				INNER JOIN C
				ON(B.idB = C.idB)
					INNER JOIN D
						ON(A.idA = D.idA);

		SELECT *
		FROM A INNER JOIN D
			ON(A.idA = D.idA);

		SELECT *
		FROM A INNER JOIN B
			ON(A.idA = B.idA)
				INNER JOIN C
				ON(B.idB = C.idB)
					INNER JOIN D
						ON(A.idA = D.idA)
							INNER JOIN F
								ON(D.idD = F.idD);

		SELECT *
		FROM A INNER JOIN D
			ON(A.idA = D.idA)
				INNER JOIN F
					ON(D.idD = F.idD);

		Reglas de los JOIN externos:
			1. Relevancia a la tabla con prioridad (desde el JOIN)
			2. Solo puedo hacer busquedas, proyecciones y restricciones sobre la tabla de prioridad
			3. Cuidar/revisar que las restricciones (WHERE, HAVING) de los atributos tengan que ver con la prioridad que se establecio (de la relación con prioridad), sino es un INNER JOIN.

		Las diferencias entre INNER JOIN y los tipos de OUTER JOIN (LEFT, RIGHT y FULL) se relacionan con cómo se combinan las filas de las tablas en la consulta JOIN.
			1. INNER JOIN: Un INNER JOIN devuelve únicamente las filas que tienen una correspondencia en ambas tablas que se están uniendo. Solo las filas que cumplen la condición de unión se incluyen en el resultado final. Si no hay una correspondencia entre las tablas, las filas no se mostrarán en el resultado.
			2. LEFT OUTER JOIN (también conocido como LEFT JOIN): Un LEFT JOIN devuelve todas las filas de la tabla izquierda (la primera tabla mencionada en la cláusula JOIN) y las filas coincidentes de la tabla derecha (la segunda tabla mencionada). Si no hay una correspondencia, se utilizan valores NULL para las columnas de la tabla derecha en el resultado.
			3. RIGHT OUTER JOIN (también conocido como RIGHT JOIN): Un RIGHT JOIN es similar a un LEFT JOIN, pero invierte el orden de las tablas. Devuelve todas las filas de la tabla derecha y las filas coincidentes de la tabla izquierda. Las filas sin correspondencia de la tabla izquierda tendrán valores NULL para las columnas de la tabla izquierda en el resultado.
			4. FULL OUTER JOIN (también conocido como FULL JOIN): Un FULL JOIN devuelve todas las filas de ambas tablas. Combina las filas de un LEFT JOIN y un RIGHT JOIN. Si no hay una correspondencia entre las tablas, se utilizan valores NULL en las columnas correspondientes.

			En resumen:
				* INNER JOIN devuelve solo las filas coincidentes entre las tablas.
				* LEFT OUTER JOIN devuelve todas las filas de la tabla izquierda y las coincidentes de la tabla derecha.
				* RIGHT OUTER JOIN devuelve todas las filas de la tabla derecha y las coincidentes de la tabla izquierda.
				* FULL OUTER JOIN devuelve todas las filas de ambas tablas, incluyendo las no coincidentes.

			La elección entre INNER JOIN y los tipos de OUTER JOIN depende de los datos que deseas obtener y cómo quieres combinar las filas de las tablas en tu consulta.

		Nombre del cargo y el nombre de todas las mujeres que sean de un departamento de finanzas.
		SELECT c.nombre AS cargo, e.nombre AS empleado
		FROM cargo AS c RIGHT OUTER JOIN empleado AS e --Right: ... y el nombre de todas ...
			ON(c.idcargo = e.idcargo)
				LEFT OUTER JOIN departamento AS d ON (e.iddepartamento = d.iddepartamento)
		WHERE e.sexo = 'M' AND d.nombre = 'Finanzas';


		El tipo de relación
		Completamente debil, full, right, left, inner
		Mitad debil-fuerte: prioridad a la tabla que tiene la parte opcional
		Completamente fuerte, inner

		Necesitamos un listado completo de cargos y de tener sus empleados que cuya ultima fecha de contratacion sea despues de 1999 diciendo cuantos empleados hay en cada uno ordenado de manera descendente por el conteo.
		SELECT c.nombre AS cargo, COUNT(*) AS conteoEmpleados
		FROM cargo AS c LEFT OUTER JOIN empleado AS e --Left: Necesitamos un listado completo .... y de tener ...
			ON(c.idCargo = e.idCargo)
		GROUP BY c.nombre
			HAVING MAX(e.contratacion) > '1999-12-31'
		ORDER BY COUNT(*) DESC;
		... cargos y ... empleados ...: JOIN
		... completo de cargos ...: LEFT

		SELECT CURRENT_TIMESTAMP; -- Para checar como es el formato de la fecha, es Estandar y por lo tanto en todos los manejadores

		Mostar los empleados y su departamento de aquellos empleados que siendo de departamentos que terminen su nombre con la 'a' o que su sueldo sobrepasen los 50,000. Considerando que no haya mujeres que sean vendedoras.
		SELECT e.nombre AS empleado, d.nombre AS departamento
		FROM empleado AS e INNER JOIN departamento AS d
			ON(e.idDepartamento = d.idDepartamento)
		WHERE e.sexo = 'M' AND e.porcentaje_comision IS NULL OR d.nombre LIKE '%_a' OR e.sueldo > 50000;

		Y si fuera lo siguiente:
		Mostrar todos los empleados y los que tengan departamento:
			FROM empleado LEFT OUTER JOIN departamento

		Mostrar cuantos departamentos hay por edad que sean departamentos cuyo promedio de sueldos sea mayor a 25,000 siendo de que cualquier cargo tengan un promedio de empleados mayor a 5.
		SELECT COUNT(d.idDepartamento) AS conteoDepartamento, e.edad --COUNT(d.idDepartamento), porque hay empleados que no tienen departamento
		FROM departamento AS d INNER JOIN empleado AS e --Mostrar cuantos ... hay por ...
			ON(d.idDepartamento = e.idDepartamento)
				RIGHT OUTER JOIN cargo AS c --... cualquier (TODOS) ....
					ON(e.idCargo = c.idCargo)
		GROUP BY e.edad
			HAVING AVG(e.sueldo) > 25000 AND COUNT(c.idCargo) > 5;

		NATURAL*	No es estandar, no es ISO, no es nada. MierdCrosoft no lo tiene.
			CROSS JOIN + RESTRICCIÓN + Atributo en común se llame igual (extremadamente idóneo).

			SELECT *
			FROM <tablaA> [IJ|ROJ|FOJ|LOJ] <tablaB>
				USING(<atributoComúnIdóneo>); --Los pocos manejadores que lo tienen, son muy eficientes

			SELECT *
			FROM empleado AS e INNER JOIN cargo AS c
				USING(idCargo);

			SELECT *
			FROM empleado AS e LEFT OUTER JOIN departamento AS d
				USING(iddepartamento);

			SELECT *
			FROM empleado AS e RIGHT OUTER JOIN departamento AS d
				USING(iddepartamento);

			SELECT *
			FROM empleado AS e FULL OUTER JOIN departamento AS d
				USING(iddepartamento);

		SELF*		Es estandar 92
			SELECT *
			FROM <tablaA> AS a [IJ|ROJ|FOJ|LOJ] <tablaA> AS b
				ON(a.<atributoComúnIdóneo> = b.<atributoComúnIdóneo>);

			ALTER TABLE empleado ADD COLUMN idJefe NUMERIC(5,0);
			ALTER TABLE empleado ADD CONSTRAINT fkEmpleadoEmpleado
				FOREIGN KEY (idJefe)
				REFERENCES empleado (idEmpleado)
				ON DELETE RESTRICT
				ON UPDATE RESTRICT;
			UPDATE empleado SET idJefe = idEmpleado + 1 WHERE idEmpleado != 19;

			empleado			jefe
			e.idEmpleado(PK)	j.idEmpleado
			...					...
			e.idJefe IS NULL	j.idJefe(FK)

			SELECT *
			FROM empleado AS e INNER JOIN empleado AS j
				ON(e.idEmpleado = j.idJefe);

			empleado			jefe/emp			jefe
			e.idEmpleado(PK)	je.idEmpleado(PK)	j.idEmpleado IS NOT NULL
			...					...					...
			e.idJefe IS NULL	je.idJefe(FK)		j.idJefe(FK)

			SELECT *
			FROM empleado AS e INNER JOIN empleado AS je
				ON(e.idEmpleado = je.idJefe)
					INNER JOIN empleado AS j
						ON(je.idEmpleado = j.idJefe); --(17 rows), porque el MASTER ya no cuenta

			Pero se recomienda salir del estándar y utilizar los objetos avanzados de cada manejador, porque son mas eficientes, y en RAM se evitan los Hacking de stackoverflow.

		GPT:
			Las diferencias entre INNER JOIN y los tipos de OUTER JOIN (LEFT, RIGHT y FULL) se relacionan con cómo se combinan las filas de las tablas en la consulta JOIN.
			1. INNER JOIN: Un INNER JOIN devuelve únicamente las filas que tienen una correspondencia en ambas tablas que se están uniendo. Solo las filas que cumplen la condición de unión se incluyen en el resultado final. Si no hay una correspondencia entre las tablas, las filas no se mostrarán en el resultado.
			2. LEFT OUTER JOIN (también conocido como LEFT JOIN): Un LEFT JOIN devuelve todas las filas de la tabla izquierda (la primera tabla mencionada en la cláusula JOIN) y las filas coincidentes de la tabla derecha (la segunda tabla mencionada). Si no hay una correspondencia, se utilizan valores NULL para las columnas de la tabla derecha en el resultado.
			3. RIGHT OUTER JOIN (también conocido como RIGHT JOIN): Un RIGHT JOIN es similar a un LEFT JOIN, pero invierte el orden de las tablas. Devuelve todas las filas de la tabla derecha y las filas coincidentes de la tabla izquierda. Las filas sin correspondencia de la tabla izquierda tendrán valores NULL para las columnas de la tabla izquierda en el resultado.
			4. FULL OUTER JOIN (también conocido como FULL JOIN): Un FULL JOIN devuelve todas las filas de ambas tablas. Combina las filas de un LEFT JOIN y un RIGHT JOIN. Si no hay una correspondencia entre las tablas, se utilizan valores NULL en las columnas correspondientes.
			En resumen:
			- INNER JOIN devuelve solo las filas coincidentes entre las tablas.
			- LEFT OUTER JOIN devuelve todas las filas de la tabla izquierda y las coincidentes de la tabla derecha.
			- RIGHT OUTER JOIN devuelve todas las filas de la tabla derecha y las coincidentes de la tabla izquierda.
			- FULL OUTER JOIN devuelve todas las filas de ambas tablas, incluyendo las no coincidentes.
			La elección entre INNER JOIN y los tipos de OUTER JOIN depende de los datos que deseas obtener y cómo quieres combinar las filas de las tablas en tu consulta.

	DIVISIÓN (÷): Se utiliza para encontrar registros en una tabla que estén relacionados con todos los valores de otra tabla.
		En SQL, no existe un operador de división directo como en el álgebra relacional. Sin embargo, es posible simular la operación de división utilizando otras consultas y operaciones disponibles en SQL. Esto puede requerir consultas más complejas.

		La operación de división en SQL puede ser replicada usando subconsultas, joins y condiciones de filtro. Aquí hay un ejemplo simplificado para ilustrar cómo se puede hacer:
			Supongamos que tenemos dos tablas: "Estudiantes" y "Cursos".
				CREATE TABLE Estudiantes (
					EstudianteID INT PRIMARY KEY,
					Nombre VARCHAR(50)
				);
				CREATE TABLE Cursos (
					CursoID INT PRIMARY KEY,
					NombreCurso VARCHAR(50)
				);
				CREATE TABLE Matriculas (
					EstudianteID INT,
					CursoID INT,
					PRIMARY KEY (EstudianteID, CursoID),
					FOREIGN KEY (EstudianteID) REFERENCES Estudiantes(EstudianteID),
					FOREIGN KEY (CursoID) REFERENCES Cursos(CursoID)
				);
			Para encontrar los estudiantes que han tomado todos los cursos, puedes usar una consulta similar a esta:
				SELECT E.EstudianteID, E.Nombre
				FROM Estudiantes E
				WHERE NOT EXISTS (
					SELECT C.CursoID
					FROM Cursos C
					EXCEPT
					SELECT M.CursoID
					FROM Matriculas M
					WHERE M.EstudianteID = E.EstudianteID
				);
			Esta consulta seleccionará los estudiantes que no tienen ningún curso que no hayan tomado. En otras palabras, solo seleccionará estudiantes que hayan tomado todos los cursos.

		Ten en cuenta que este es solo un ejemplo simplificado y que la implementación de la división en SQL puede volverse más compleja dependiendo de la estructura de tus tablas y la lógica específica que estés utilizando.



Subconsultas: Una o varias consultas anidadas dentro de otra.
	Tipos:
	1. Restricción: WHERE (SELECT)
		Reglas:
			1. Toda subconsulta debe tener grado 1.
				SELECT * FROM empleado WHERE idcargo = (SELECT idCargo, nombre FROM cargo); --ERROR:  subquery must return only one column
			2. Si la cardinalidad de retorno es 1, se usa =, sino se usa IN.
				SELECT * FROM empleado WHERE idCargo = (SELECT idCargo FROM cargo); --ERROR:  more than one row returned by a subquery used as an expression
				SELECT * FROM empleado WHERE idCargo IN (SELECT idCargo FROM cargo);
				SELECT * FROM empleado WHERE idCargo = (SELECT MAX(idCargo) FROM cargo);
				SELECT * FROM empleado WHERE idCargo IN (SELECT MAX(idCargo) FROM cargo); --Muy estupida, porque en el IN solo tiene un valor

				SELECT * FROM empleado WHERE idCargo IN (SELECT idCargo FROM cargo);
				SELECT idCargo FROM cargo;
				 idcargo 
				---------
				       1 
				       2 
				       3 
				       4 
				       5 
				       6 
				(6 rows) 
				SELECT * FROM empleado WHERE idCargo IN (1,2,3,4,5,6);
				----------------------------------------------------------------------
				SELECT * FROM empleado WHERE idCargo = (SELECT idCargo FROM cargo WHERE idCargo = 1);
				SELECT idCargo FROM cargo WHERE idCargo = 1;
				 idcargo 
				---------
				       1 
				(1 row)  
				SELECT * FROM empleado WHERE idCargo = (1);
				SELECT * FROM empleado WHERE idCargo = 1;

		SELECT *
		FROM empleado
		WHERE sueldo = (SELECT MAX(sueldo)
			FROM empleado
			WHERE sexo = 'M'
		) AND sexo = 'H';

		--Las restricciones que estan dentro de la primer consulta (subconsulta), no se "heredan/pasan/comparten" con las restricciones de la consulta padre (superior).
		SELECT *
		FROM empleado
		WHERE idCargo = (SELECT MAX(idCargo)
			FROM cargo
			WHERE nombre LIKE '%_o'
		) AND sexo = 'H';

		--No importa si el resultado de la consulta inferior/subconsulta son 0 renglones, el manejador lo interpreta como el digito 0 y trabaja con ello sin problema alguno.
		SELECT *
		FROM empleado
		WHERE idCargo = (SELECT idCargo
			FROM cargo
			WHERE idCargo = 19
		) AND sexo = 'H';

		--Si en el los JOINs, no se ocupta al menos UN ATRIBUTO de cada TABLA, sustituye eso por una subconsulta.
		Nombre del cargo y el nombre de todas las mujeres que sean de un departamento de finanzas.
		SELECT c.nombre AS cargo, e.nombre AS empleado
		FROM cargo AS c RIGHT OUTER JOIN empleado AS e --Right: ... y el nombre de todas ...
			ON(c.idcargo = e.idcargo)
				LEFT OUTER JOIN departamento AS d ON (e.iddepartamento = d.iddepartamento)
		WHERE e.sexo = 'M' AND d.nombre = 'Finanzas'; --En este JOIN no ocupo los atributos de departamento
		--Por lo tanto:
		SELECT c.nombre AS cargo, e.nombre AS empleado
		FROM cargo AS c RIGHT OUTER JOIN empleado AS e --Right: ... y el nombre de todas ...
			ON(c.idcargo = e.idcargo)
		WHERE e.sexo = 'M' AND e.iddepartamento = (SELECT idDepartamento
			FROM departamento
			WHERE nombre = 'Finanzas');

		Nivel leve: Mostrar el nombre de la mujer que gane más que el sueldo promedio de los hombres de cargo 1.
			SELECT nombre
			FROM empleado
			WHERE sexo = 'M' AND sueldo > (SELECT AVG(sueldo)
					FROM empleado
					WHERE sexo = 'H' AND idCargo = 1);

		Nivel medio: Mostrar el nombre del empleado hombre que tenga la edad más pequeña y la más grande de las mujeres
			SELECT nombre
			FROM empleado
			WHERE sexo = 'H' AND edad BETWEEN (SELECT MIN(edad)
				FROM empleado
				WHERE sexo = 'M') AND (SELECT MAX(edad)
				FROM empleado
				WHERE sexo = 'M');
	2. Tablas Temporales: FROM (SELECT...)
		GPT: Puedes utilizar una subconsulta en la cláusula FROM para crear una tabla temporal y utilizarla en la consulta principal. Aquí tienes un ejemplo de sintaxis genérica:
		SELECT columna1, columna2, ...
		FROM (SELECT columna1, columna2, ...
			FROM tabla_principal
			WHERE condicion) AS tabla_temporal;

		En este ejemplo, la subconsulta se utiliza para filtrar los datos de la tabla principal y se almacenan en una tabla temporal llamada "tabla_temporal". Luego, la consulta principal se ejecuta utilizando la tabla temporal como origen de datos.
		Recuerda que estos ejemplos son solo representativos de la sintaxis general y pueden variar según la base de datos que estés utilizando. Siempre es recomendable consultar la documentación específica del sistema de gestión de bases de datos que estés utilizando para obtener información más precisa sobre cómo utilizar subconsultas en diferentes contextos.

		Casos comunes de uso:
			* Creación de tablas derivadas: Cuando necesitas realizar una operación en una tabla antes de unir o relacionar sus datos con otra(s) tabla(s).
			* Resumen de datos: Puedes usar subconsultas para calcular agregaciones como la suma, el promedio, etc.
			* Filtrado avanzado: Puedes aplicar filtrado complejo y condiciones a la tabla temporal generada por la subconsulta.
	3. Queries Correlacionales: SELECT (SELECT...)
		GPT: En esta sección, puedes utilizar una subconsulta dentro de la cláusula SELECT para realizar cálculos o recuperar valores relacionados con cada fila de la consulta principal. Aquí tienes un ejemplo de sintaxis genérica:
		SELECT columna1, columna2, ..., (SELECT columna FROM tabla_secundaria WHERE condicion) AS columna_nueva
		FROM tabla_principal;
		En este ejemplo, la subconsulta se encuentra dentro de la cláusula SELECT y se utiliza para recuperar un valor relacionado con cada fila de la tabla principal. El resultado de la subconsulta se muestra como una columna adicional llamada "columna_nueva" en la consulta principal.
		Recuerda que estos ejemplos son solo representativos de la sintaxis general y pueden variar según la base de datos que estés utilizando. Siempre es recomendable consultar la documentación específica del sistema de gestión de bases de datos que estés utilizando para obtener información más precisa sobre cómo utilizar subconsultas en diferentes contextos.


		

Objetos avanzados:
	TRIGERRS/Guardian de la BD que reacciona ante nuevos,cambios y borrado de datos.
		DE INTEGRIDAD REFENCIAL
	PROCEDIMIENTOS ALMACENADOS
	CURSORES

4 tratados de Codd, leer 2 y 3:
	1. No hay ningún orden y que todos son conjuntos.
	2. Las tuplas estan en desorden.
	3. Los atributos estan en desorden.
	4. No existen tuplas repetidas.

Tips:
	SELECT a.sexo, a.nombre
	FROM empleado AS a; --Consulta muy inutil, porque no se incluyen mas tablas (solo una), especificación de sobra.

	SELECT sexo, sueldo, MAX(edad) AS maxEdad
	FROM empleado
	GROUP BY sexo, sueldo, edad; --Consulta muy inutil, porque no tiene sentido agrupar edad, si ya se tiene la MAXIMA (un solo tipo de valor) edad

	SELECT sexo, sueldo, MAX(edad) AS maxEdad, COUNT(porcentaje_comision) conteoComision
	FROM empleado
	GROUP BY sexo, sueldo
	ORDER BY sueldo DESC, conteoComision ASC; --Ordenar mediante el alias, no es estandar.

	Si en la PROYECCIÓN solo se muestran los atributos de una tabla, cambiar el JOIN con subconsultas (Queries Correlacionales: IF EXISTS, SOME, ANY)
	SELECT a.sueldo
		a.sueldo,
		MAX(a.edad) AS maxEdad,
		COUNT(a.porcentaje_comision) AS conteoComision
	FROM empleado AS a INNER JOIN departamento o
		ON(a.iddepartamento = o.iddepartamento)
	WHERE (a.nombre LIKE '[A,Z,Y]%o'
		OR a.edad BETWEEN 15 AND 35)
		AND a.idCargo != 3
	GROUP BY a.sexo, a.sueldo--, a.edad
		HAVING MIN(a.contratacion) != '01-01-2000'
			AND MAX(a.paterno) NOT IN ('Hernandez', 'Juarez')
	ORDER BY a.sueldo DESC, COUNT(a.porcentaje_comision) ASC;

	Y en este AUNQUE no se "utilicen" los atributos de departamento, simplemente como se creo pares ordenados, ya es VALIDO.
	SELECT a.sueldo
		a.sueldo,
		MAX(a.edad) AS maxEdad,
		COUNT(a.porcentaje_comision) AS conteoComision
	FROM empleado AS a CROSS JOIN departamento o
	WHERE (a.nombre LIKE '[A,Z,Y]%o'
		OR a.edad BETWEEN 15 AND 35)
		AND a.idCargo != 3
	GROUP BY a.sexo, a.sueldo--, a.edad
		HAVING MIN(a.contratacion) != '01-01-2000'
			AND MAX(a.paterno) NOT IN ('Hernandez', 'Juarez')
	ORDER BY a.sueldo DESC, COUNT(a.porcentaje_comision) ASC;

















Haydeé Meza - haydeek.meza@gmail.com

MÓDULO IV
PROGRAMACIÓN AVANZADA DE BASES DE DATOS
1. Lenguajes de programación de bases de datos
1.1. PL/SQL
1.2. Transact-SQL
1.3. Otros
2. Procedimientos almacenados de base de datos
2.1. Programación de disparadores
2.2. Programación de procedimientos
2.3. Programación de funciones
3. Manejo de transacciones
3.1. Funcionamiento de una transacción
3.2. El LOG de transacciones
3.3. Recuperación de transacciones
3.4. Programación de transacciones
4. Cursores
4.1. Conceptos básicos
4.2. Cursores en procedimientos almacenados
5. Características orientadas a objetos
5.1. Herencia de tablas
5.2. Tipos de datos complejos
5.2.1. Manejo de arreglos
5.3. Tipos de datos definidos por el usuario

-----------Esquema.sql-----------
DROP DATABASE IF EXISTS "<bd>";
CREATE DATABASE "<bd>";
USE "TSqlTest"; --SqlServer
\c "pgSqlTest" --PostgreSql

DROP TABLE IF EXISTS productos;
CREATE TABLE productos (categoriaId NUMERIC(2,0), productoId NUMERIC(2,0), nombre VARCHAR(30), precio NUMERIC(10,2));

EXECUTE sp_columns productos; --SqlServer
\d+ productos --PostgreSql
-----------Esquema.sql-----------

-----------Datos.sql-----------
TRUNCATE TABLE productos;
INSERT INTO productos (categoriaId, productoId, nombre, precio) VALUES(1,1,'Nombre1',1),(2,2,'Nombre2',2),(3,3,'Nombre3',3);
SELECT * FROM productos;
-----------Datos.sql-----------

Aquí tienes una tabla comparativa entre PostgreSQL, SQL Server y MySQL en relación a las características solicitadas:
|-------------------|-------------------------------------------|-------------------------------------------|-------------------------------------------|
| Característica    | PostgreSQL (PL/pgSQL)                     | SQL Server (Transact-SQL)                 | MySQL (SQL)                               |
|-------------------|-------------------------------------------|-------------------------------------------|-------------------------------------------|
| Function          | Compatible con la creación de funciones,  | Compatible con la creación de funciones,  | Compatible con la creación de funciones,  |
|                   | tanto en lenguajes de programación como   | tanto en lenguajes de programación como   | tanto en lenguajes de programación como   |
|                   | en SQL.                                   | en SQL.                                   | en SQL.                                   |
|-------------------|-------------------------------------------|-------------------------------------------|-------------------------------------------|
| Procedure         | Compatible con la creación de             | Compatible con la creación de             | Compatible con la creación de             |
|                   | procedimientos almacenados (Stored        | procedimientos almacenados (Stored        | procedimientos almacenados (Stored        |
|                   | Procedures).                              | Procedures).                              | Procedures).                              |
|-------------------|-------------------------------------------|-------------------------------------------|-------------------------------------------|
| Trigger           | Compatible con la creación de triggers    | Compatible con la creación de triggers    | Compatible con la creación de triggers    |
|                   | (disparadores) para realizar acciones     | (disparadores) para realizar acciones     | (disparadores) para realizar acciones     |
|                   | automáticas en respuesta a eventos.       | automáticas en respuesta a eventos.       | automáticas en respuesta a eventos.       |
|-------------------|-------------------------------------------|-------------------------------------------|-------------------------------------------|
| Cursor            | Compatible con cursores, permitiendo      | Compatible con cursores, permitiendo      | Compatible con cursores, permitiendo      |
|                   | iterar a través de resultados de          | iterar a través de resultados de          | iterar a través de resultados de          |
|                   | consultas.                                | consultas.                                | consultas.                                |
|-------------------|-------------------------------------------|-------------------------------------------|-------------------------------------------|
| If, else if, else | Compatible con estructuras condicionales. | Compatible con estructuras condicionales. | Compatible con estructuras condicionales. |
|                   | Puede usar CASE dentro de consultas SQL.  | Puede usar CASE dentro de consultas SQL.  | Puede usar CASE dentro de consultas SQL.  | 
|-------------------|-------------------------------------------|-------------------------------------------|-------------------------------------------|
| Switch Case       | No cuenta con una estructura de control   | Cuenta con la estructura Switch Case.     | No cuenta con una estructura de control   |
|                   | Switch Case.                              | Puede ser utilizada en consultas SQL.     | Switch Case.                              |
|                   | Es posible emularla con múltiples         |                                           | Es posible emularla con múltiples         |
|                   | condicionales IF.                         |                                           | condicionales IF.                         |
|-------------------|-------------------------------------------|-------------------------------------------|-------------------------------------------|
| For               | Compatible con la estructura de control   | Compatible con la estructura de control   | Compatible con la estructura de control   | 
|                   | FOR LOOP para iterar en consultas SQL.    | FOR para iterar en consultas SQL.         | FOR para iterar en consultas SQL.         |
|-------------------|-------------------------------------------|-------------------------------------------|-------------------------------------------|
| While             | Compatible con la estructura de control   | Compatible con la estructura de control   | Compatible con la estructura de control   |
|                   | WHILE LOOP para iterar en consultas SQL.  | WHILE para iterar en consultas SQL.       | WHILE para iterar en consultas SQL.       |
|-------------------|-------------------------------------------|-------------------------------------------|-------------------------------------------|

Functions - PostgreSQL

	Las funciones almacenadas en pgSQL te permiten definir bloques de código reutilizables que se pueden invocar desde consultas o desde otras funciones.

	Hay dos tipos de funciones almacenadas en Pl/Pgsql:
	a) Funciones escalares: Devuelven un solo valor y se utilizan como parte de una expresión, utilizando la cláusula "RETURNS <tipoDato> AS $$" y la declaración "RETURN" para retornar el dato. Para invocar dicha función es con el "SELECT".
		----------------------------------------------------
		DROP FUNCTION IF EXISTS duplicar;
		CREATE FUNCTION duplicar(numero NUMERIC(2,0))
		RETURNS NUMERIC(2,0) AS $$
		BEGIN
			RETURN numero * 2;
		END;
		$$ LANGUAGE plpgsql;
		SELECT duplicar(5);
		-- Devuelve
		-- | 10 |
		----------------------------------------------------
		DROP FUNCTION IF EXISTS calcularPrecioTotal;
		CREATE FUNCTION calcularPrecioTotal(precioUnitario NUMERIC(10,2), cantidad NUMERIC(2,0))
		RETURNS NUMERIC(10,2) AS $$
		DECLARE precioTotal NUMERIC(10,2);
		BEGIN
			precioTotal := precioUnitario * cantidad;
			RETURN precioTotal;
		END;
		$$ LANGUAGE plpgsql;
		SELECT calcularPrecioTotal(2,2);
		-- Devuelve 
		-- | 4.00 |
		----------------------------------------------------
		DROP FUNCTION IF EXISTS obtenerUnNombre;
		CREATE FUNCTION obtenerUnNombre()
		RETURNS VARCHAR(30) AS $$
		DECLARE miNombre VARCHAR(30);
		BEGIN
			SELECT nombre INTO miNombre FROM productos;
			RETURN miNombre;
		END;
		$$ LANGUAGE plpgsql;
		SELECT obtenerUnNombre();
		-- Devuelve
		-- | Nombre1 |
		----------------------------------------------------
	b) Funciones de tabla en línea: Devuelven una tabla resultante utilizando la cláusula "RETURNS <tipoDato> AS $$" o "RETURNS SETOF <tabla> AS $$" y la declaración "RETURN <variable>" o "RETURN QUERY <consulta>" para especificar el dato o los datos que se van a devolver. Para invocar dicha función es con el "SELECT".
		----------------------------------------------------
		DROP FUNCTION IF EXISTS obtenerProductosPorCategoria;
		CREATE FUNCTION obtenerProductosPorCategoria(miCategoriaId NUMERIC(10,2))
		RETURNS SETOF productos AS $$
		BEGIN
			RETURN QUERY SELECT * FROM productos WHERE categoriaId = miCategoriaId;
		END;
		$$ LANGUAGE plpgsql;
		SELECT * FROM obtenerProductosPorCategoria(2);
		-- Devuelve
		-- | 2 | 2 | Nombre2 | 2.00
		----------------------------------------------------
	c) Funciones de tabla con valores: Devuelven una tabla como resultado utilizando la cláusula "RETURNS TABLE (<structureTable>) AS $$" y la declaración "RETURN" para especificar los datos (mediante una consulta) de la tabla que se van a devolver. Para invocar dicha función es con el "SELECT".
		----------------------------------------------------
		DROP FUNCTION IF EXISTS obtenerProductosCaros;
		CREATE FUNCTION obtenerProductosCaros(precioLimite NUMERIC(10,2))
		RETURNS TABLE (miProductoId NUMERIC(2,0), miNombre VARCHAR(30), miPrecio NUMERIC(10,2)) AS $$
		BEGIN
			RETURN QUERY SELECT productoId, nombre, precio FROM productos WHERE precio > precioLimite;
		END;
		$$ LANGUAGE plpgsql;
		SELECT * FROM obtenerProductosCaros(1);
		-- Devuelve
		-- | 2 | Nombre2 | 2.00
		-- | 3 | Nombre3 | 3.00
		----------------------------------------------------
		DROP FUNCTION IF EXISTS obtenerNombres;
		CREATE FUNCTION obtenerNombres()
		RETURNS TABLE (miNombre VARCHAR(30)) AS $$
		BEGIN
			RETURN QUERY SELECT nombre FROM productos;
		END;
		$$ LANGUAGE plpgsql;
		SELECT obtenerNombres();
		-- Devuelve
		-- | Nombre1 |
		-- | Nombre2 |
		-- | Nombre3 |
		----------------------------------------------------


Functions - SQL Server

	Las funciones almacenadas son bloques de código T-SQL que se pueden invocar para realizar cálculos o procesamientos y devolver un valor. Estas funciones pueden aceptar parámetros de entrada y pueden ser utilizadas en expresiones T-SQL en consultas SELECT, WHERE, JOIN, etc.

	Hay dos tipos de funciones almacenadas en T-SQL:
	a) Funciones escalares: Devuelven un solo valor y se utilizan como parte de una expresión, utilizando la cláusula "RETURNS <tipoDato>" y la declaración "RETURN" para retornar el dato. Para invocar dicha función se puede hacer de dos formas, con el "SELECT" o con el "PRINT".
		----------------------------------------------------
		DROP FUNCTION IF EXISTS dbo.duplicar;
		GO;
		CREATE FUNCTION duplicar(@numero NUMERIC(2,0))
		RETURNS NUMERIC(2,0)
		AS
		BEGIN
			RETURN @numero * 2;
		END;
		GO;
		SELECT dbo.duplicar(5);
		-- Devuelve 
		-- | 10 |
		PRINT dbo.duplicar(5);
		-- Devuelve
		-- 10
		GO;
		----------------------------------------------------
		DROP FUNCTION IF EXISTS dbo.calcularPrecioTotal;
		GO;
		CREATE FUNCTION dbo.calcularPrecioTotal(@precioUnitario NUMERIC(10,2), @cantidad NUMERIC(2,0))
		RETURNS NUMERIC(10,2)
		AS
		BEGIN
			DECLARE @precioTotal NUMERIC(10,2);
			SET @precioTotal = @precioUnitario * @cantidad;
			RETURN @precioTotal;
		END;
		GO;
		SELECT dbo.calcularPrecioTotal(2,2);
		-- Devuelve
		-- | 4.00 |
		PRINT dbo.calcularPrecioTotal(2,2);
		-- Devuelve
		-- 4.00
		GO;
		----------------------------------------------------
		DROP FUNCTION IF EXISTS dbo.obtenerUnNombre;
		GO;
		CREATE FUNCTION dbo.obtenerUnNombre()
		RETURNS VARCHAR(30)
		AS
		BEGIN
			DECLARE @miNombre VARCHAR(30);
			SET @miNombre = (SELECT nombre FROM productos WHERE productoId = 1);
			RETURN @miNombre;
		END;
		GO;
		SELECT dbo.obtenerUnNombre();
		-- Devuelve
		-- | Nombre1 |
		PRINT dbo.obtenerUnNombre();
		-- Devuelve
		-- Nombre1
		GO;
		----------------------------------------------------
	b) Funciones de tabla en línea: Devuelven una tabla resultante utilizando la cláusula "RETURNS TABLE" o "RETURNS <tipoDato>" y la declaración "RETURN" para especificar la estructura de la tabla y los datos que se van a devolver. Para invocar dicha función es con el "SELECT".
		----------------------------------------------------
		DROP FUNCTION IF EXISTS dbo.obtenerProductosPorCategoria;
		GO;
		CREATE FUNCTION dbo.obtenerProductosPorCategoria(@miCategoriaId NUMERIC(10,2))
		RETURNS TABLE
		AS
		RETURN
		(
			SELECT *
			FROM productos
			WHERE categoriaId = @miCategoriaId
		);
		GO;
		SELECT * FROM dbo.obtenerProductosPorCategoria(2);
		-- Devuelve
		-- | 2 | 2 | Nombre2 | 2.00 |
		GO;
		----------------------------------------------------
	c) Funciones de tabla con valores: Devuelven una tabla como resultado utilizando la cláusula "RETURNS @table_variable" y la declaración "INSERT" para llenar la variable de tabla con los datos que se van a devolver.
		----------------------------------------------------
		DROP FUNCTION IF EXISTS dbo.obtenerProductosCaros;
		GO;
		CREATE FUNCTION dbo.obtenerProductosCaros(@precioLimite NUMERIC(10,2))
		RETURNS @ProductosCaros TABLE
		(
			productoId NUMERIC(2,0),
			nombre VARCHAR(30),
			precio NUMERIC(10,2)
		)
		AS
		BEGIN
			INSERT INTO @ProductosCaros
			SELECT productoId, nombre, precio
			FROM productos
			WHERE precio > @precioLimite;
		    RETURN;
		END;
		GO;
		SELECT * FROM dbo.obtenerProductosCaros(1);
		-- Devuelve
		-- | 2 | Nombre2 | 2.00 |
		-- | 3 | Nombre3 | 3.00 |
		GO;
		----------------------------------------------------
		DROP FUNCTION IF EXISTS dbo.obtenerNombres;
		GO;
		CREATE FUNCTION dbo.obtenerNombres()
		RETURNS TABLE
		AS
		RETURN
		(
			SELECT nombre
			FROM productos
		);
		GO;
		SELECT * FROM dbo.obtenerNombres();
		-- Devuelve
		-- | Nombre1 |
		-- | Nombre2 |
		-- | Nombre3 |
		GO;
		----------------------------------------------------


Functions - MySQL


Procedures - PostgreSQL


Procedures - SQL Server


Procedures - MySQL


Triggers - PostgreSQL


Triggers - SQL Server


Triggers - MySQL



20% Tareas
	1. 25 enero, antes de las 17
		Asunto: Diplomado Tarea 1 - <paterno> <materno>
		Screenshots en Word
20% Prácticas
10% Examen (clase 7)
50% Proyecto (clase 8)



1. Lenguajes de programación de bases de datos
1.1. PL/SQL (Oracle)
	SQL es un lenguaje de conjuntos muy poderoso, cuyo único objetivo es manipular el contenido de bases de datos relacionales. Sin embargo, SQL no se puede utilizar para implementar toda la lógica de negocios y la funcionalidad que el usuario final necesita en nuestras aplicaciones. Esto nos lleva a PL/SQL.
	PL/SQL (Programing Language/Structured Query Language) es un lenguaje de programación de 5ª generación incrustado en Oracle. En el Kernel de Oracle interpreta SQL y PL/SQL. Así como el Kernel es un sistema operativo, el Kernel Oracle es cargado a la memoria al inicio de las operaciones y es usado por cada base de datos existente en el equipo.
	PL/SQL: es un lenguaje portable, procedural y de transacción muy potente y de fácil manejo, con las siguientes características fundamentales:
		1. Incluye todos los comandos de SQL.
		2. Es una extensión de SQL, ya que este es un lenguaje no completo dado que no incluye las herramientas clásicas de programación. Por eso, PL/SQL, amplía sus posibilidades al incorporar las siguientes sentencias:
			• Control condicional
			• Ciclos
		3. Incorpora opciones avanzadas en:
			• Control y tratamiento de errores llamado excepciones.
			• Manejo de cursores.
	PL/SQL ofrece un conjunto de instrucciones clásicos de la programación estructurada (instrucción condicional IF, loops o iteraciones, asignaciones), organizado dentro de bloques (lo que se explica más adelante), que complementan y amplían el alcance de SQL.
	Sin duda que es posible crear aplicaciones sobre Oracle y SQL sin usar PL/SQL. Sin embargo, utilizar PL/SQL para realizar operaciones específicas de bases de datos, particularmente la ejecución de sentencias SQL, ofrece varias ventajas, incluyendo una estrecha integración con SQL, un mejor rendimiento a través del tráfico de red reducido, y la portabilidad (los programas PL/SQL pueden correr en cualquier instancia de base de datos Oracle). Por lo tanto, el código del front-end de muchas aplicaciones ejecuta tantas sentencias SQL como bloques PL/SQL, para maximizar el rendimiento al tiempo que mejora la capacidad de mantenimiento de las aplicaciones.
1.2. Transact-SQL (SqlServer)
	https://learn.microsoft.com/es-es/training/modules/get-started-transact-sql-programming/
1.3. Otros
2. Procedimientos almacenados de base de datos
2.1. Programación de disparadores
	Un "trigger" (disparador o desencadenador) es un tipo de procedimiento almacenado que se ejecuta cuando se intenta modificar los datos de una tabla (o vista).
	Se definen para una tabla (o vista) específica.
	Se crean para conservar la integridad referencial y la coherencia entre los datos entre distintas tablas.
	Si se intenta modificar (agregar, actualizar o eliminar) datos de una tabla en la que se definió un disparador para alguna de estas acciones (inserción, actualización y eliminación), el disparador se ejecuta (se dispara) en forma automática.
	Un trigger se asocia a un evento (inserción, actualización o borrado) sobre una tabla.
	La diferencia con los procedimientos almacenados del sistema es que los triggers:
	• No pueden ser invocados directamente; al intentar modificar los datos de una tabla para la que se ha definido un disparador, el disparador se ejecuta automáticamente.
	• No reciben y retornan parámetros.
	• Son apropiados para mantener la integridad de los datos, no para obtener resultados de consultas.
	• Los disparadores, a diferencia de las restricciones "check", pueden hacer referencia a campos de otras tablas. Por ejemplo, puede crearse un trigger de inserción en la tabla "ventas" que compruebe el campo "stock" de un artículo en la tabla "articulos"; el disparador controlaría que, cuando el valor de "stock" sea menor a la cantidad que se intenta vender, la inserción del nuevo registro en "ventas" no se realice.
	• Los disparadores se ejecutan DESPUES de la ejecución de una instrucción "insert", "update" o "delete" en la tabla en la que fueron definidos. Las restricciones se comprueban ANTES de la ejecución de una instrucción "insert", "update" o "delete". Por lo tanto, las restricciones se comprueban primero, si se infringe alguna restricción, el desencadenador no llega a ejecutarse.
	• Los triggers se crean con la instrucción "create trigger". Esta instrucción especifica la tabla en la que se define el disparador, los eventos para los que se ejecuta y las instrucciones que contiene.
	CREATE TRIGGER <trigger>
		ON {<tabla>|<vista>}
			{FOR|AFTER|INSTEAD OF} --al instante, despues, antes
			[INSERT][,][UPDATE][,][DELETE]
		AS
			<querySql>;
	Donde:
	"create trigger" junto al nombre del disparador.
	"on" seguido del nombre de la tabla o vista para la cual se establece el trigger.
	luego de "for", se indica la acción (evento, el tipo de modificación) sobre la tabla o vista que activará el trigger. Puede ser "insert", "update" o "delete". Debe colocarse al menos UNA acción, si se coloca más de una, deben separarse con comas.
	luego de "as" viene el cuerpo del trigger, se especifican las condiciones y acciones del disparador; es decir, las condiciones que determinan cuando un intento de inserción, actualización o borrado provoca las acciones que el trigger realizará.
2.2. Programación de procedimientos
2.3. Programación de funciones
3. Manejo de transacciones
3.1. Funcionamiento de una transacción
3.2. El LOG de transacciones
3.3. Recuperación de transacciones
3.4. Programación de transacciones
4. Cursores
4.1. Conceptos básicos
4.2. Cursores en procedimientos almacenados
5. Características orientadas a objetos
5.1. Herencia de tablas
5.2. Tipos de datos complejos
5.2.1. Manejo de arreglos
5.3. Tipos de datos definidos por el usuario





















MÓDULO V - 4 al 11 de Marzo en linea
ADMINISTRACIÓN DE LA BASE DE DATOS
1. Funciones del DBA
2. Administración del servidor
2.1. Detener, arrancar y reiniciar un servidor
2.2. Opciones de arranque
3. Administración del catálogo
3.1. Tablas del sistema
3.2. Vistas del sistema
4. Importación y exportación de datos
5. Monitoreo del sistema
6. Programación de tareas rutinarias
7. Ajustes de configuración de rendimiento
8. Optimización de consultas

Dra. Adriana García Vargas

https://www.javatpoint.com/mysql-export-table-to-cvs
https://www.postgresql.org/docs/current/sql-createrole.html#:~:text=CREATE%20ROLE%20adds%20a%20new,about%20managing%20users%20and%20authentication.
https://www.postgresql.org/docs/current/catalogs-overview.html
https://community.qlik.com/t5/Official-Support-Articles/PostgreSQL-postgresql-conf-and-pg-hba-conf-explained/ta-p/1713744

Actividades			40%
Examenes			30%
Video de un tema	30%

https://extracurriculares.fca.unam.mx/docencia


https://hireline.io/mx/enciclopedia-de-perfiles-ti/perfil-de-administrador-de-bases-de-datos
Perfil de Administrador de Bases de Datos?
1. ¿Qué es un Administrador de Bases de Datos?
	Mantenimiento
	Implementar mecanismos de seguridad
	Actualiza
	Reorganizar para optimización y uso
	Respaldos
	Establecer políticas y procedimientos de seguridad
	Diseño
	Implementación
	Actualización de las nuevas tecnologías y enfoques de diseño
	Perfil no es tan colaborativo
	Contacto con la mayoría de los demás departamentos de una empresa
	Comprensión del entorno de la industria
	Previene y evita las interrupciones de los sistemas informáticos
2. ¿Qué son las Bases de Datos?
	Recopilación de datos organizados de diferentes maneras y almacenados de forma electrónica en sistemas informáticos.
	Controlados por los DBMS (sistemas de gestión de bases de datos).
	Estos son algunos tipos de bases de datos:
		BD relacionales
		BD orientados a objetos
		BD NoSQL
		BD OLTP
		BD de código abierto
		BD en la nube
		BD de documentos /JSON
		BD de autogestión
3. Tipos de Administrador de Bases de Datos
	Administrador de bases de datos del sistema
	Arquitecto de bases de datos
	Analista de bases de datos
	Administrador de bases de datos de aplicaciones
	Administrador de bases de datos orientados a tareas
	Administrador de bases de datos en la nube
4. ¿Qué hace un Administrador de Bases de datos?
	Responsable de crear, manejar, mantener y las bases de datos de un sistema informático en una empresa.
	Diseñar nuevos modelos que se adapten a las necesidades emergentes de las empresas.
	Trabajar colaborativamente con desarrolladores.
		Verificar que los diseños de aplicaciones o software que realicen los programadores, sea compatible con las bases de datos.
	Crear sistemas de respaldo
		Planes de contingencia para emergencias, con los que se pueda tener un punto de partida para actuar en caso de que haya problemas con las bases de datos.
	Supervisa la actividad
		El DBA debe tener acceso a la información para saber cuándo se realizaron retrotracciones de información.
5. Perfil de Administrador de Bases de Batos
	Simplemente habilidades de organización y pensamiento analítico.
	Conocimientos
		Creación de la BD
		Acceso y la actualización de datos en diferentes niveles
		Almacenamiento
		Recuperación
		Disponibilidad de datos
		Seguridad
		Privacidad
	RDBMS
		MySQL
		MariaDB
		SQLite
		Microsoft SQL Server
		Oracle
	DBMS no relacionales
		MongoDB
		Redis
		Cassandra
		Azure Cosmos DB
		RavenDB
	Nube/DBaaS
		AWS
		Google Cloud
		Microsoft Azure
		Private Cloud OpenStack
		VMware
	Big Data: manejo de grandes volúmenes de datos, ya sean estructurados o no estructurados.
		Utiliza las NoSQL.
	Migración de datos: transferir información de un origen a otro destino, desactivando la base de origen una vez completado el proceso.
	Backup y recover: copias creadas de la información alojada en bases de datos, cuyo fin es disponer de ellas en caso de perdida de los originales.
	Hard Skills
		Lenguajes de administración de bases de datos
		Conocimientos de informática
		Conocimientos de protección de datos
		Actualizado
		Conocimiento de negocios
	Soft Skills
		Trabajo bajo presión
		Organizado
		Comunicación efectiva
		Analítico
		Responsable
6. Sueldo Mexicano: Administrador de Bases de Datos
	Nuevo León	$37,012.20
	Ciudad de México	$40,198.76
	Querétaro	$58,592.59
	Jalisco	$39,411.76
	Remoto: LATAM	$44,062.50
	Remoto: México	$47,590.00
	Hidalgo	$22,500.00
	Quintana Roo	$65,625.00
	Guanajuato	$52,500.00
	Estado de México	$31,000.00
	Yucatán	$32,500.00
	Colima	$32,500.00
	Sinaloa	$33,750.00
	Baja California Norte	$2,000.00
	Sonora	$27,500.00
	Chihuahua	$32,500.00


Información: Recurso cada vez más critico e importante para las empresas y organizaciones. Por ello es crucial disponer de herramientas que permitan y faciliten su administración. Además del personal con los conocimientos competencias y habilidades necesarias.

Para implementar una estrategia exitosa de administración de bd se requiere que los datos sean considerados recursos importantes y valiosos para ser tratados y manejados como activos corporativos.

Dato: Representación simbolica sin ningun sentido semántico describiendo situtaciones y hechos sin transmitir mensaje alguno. Puede ser numero, letra, hecho.
Dato no tiene sentido en si mismo, sino que se utiliza en la toma de decisiones o en la realización de calculos a partir de un procesamiento adecuado y teniendo en cuenta su contexto.

Información: Conjunto de datos procesados con significado y relevancia dentro de un contexto.
	Exactitud
	Completa
	Económica
	Confiable
	Relevante
	Simple
	Oportuno
	Verificable

BD: Conjunto de datos relacionados y organizados con cierta estructura. Segun dicha organización distinguimos entre diferentes modelos de bd como el relacional, jerárquicos o en red.

SGBD: Sistema que permite a los usuarios definir, crear y mantener bd proporcionando acceso controlado a las mismas. Es una herramienta que sirve de interfaz entre el usaurio y las bd.

DBA encargado del diseño fisico, implementación, control de la seguridad, concurrencia. Mantiene el sistema para que siempre se encuentre operativo y se encarga de que los usuarios y las apps obtengan buenas prestaciones. Debe conocer el SGBD, como el equipo informático. Control de acceso de usuarios. Tener una gran resposabilidad ya que posee el maximo nivel de privilegios entre los que se encuentra crear usuarios.

Habilidades del DBA:
	Tecnicas
		Uso del SGBD
		Diseño
		Desarrollo
		Ejecución
		Producción, desarrollo y uso de programas
		Diagrama de flujo
		Programar
		Diagrama conceptual
		Diagrama logico
		Diagrama fisico
	Administrativas
		Manejo del personal
		Interacción con la comunidad de usuarios
		Conocimientos general del negocio
		Coordinación
		Analitico
		Resolución de conflictos
		Negociación

Politicas, procedimientos y normas
Estrategia de administración de datos exitosa es el establecimiento y aplicación continua de políticas, p y n para la correcta creación, uso y eliminación de datos dentro de la bd.
El DBA debe definir, documentar y comunicar las políticas, p y n antes que puedan aplicarse.

Las políticas, normas y procedimientos deben ser revisados cada 6 meses.

Politica: Declaración general de direccion o accion que comunican y sustentan los objetivos del DBA.
	Todos los usuarios deben tener passwords.
	Passwords cambiados cada 6 meses.
	Passwords cifrados.

	3 p tecnicas
Contraseñas seguras.
	Mínimo 12 caracteres.
	Máximo 16 caracteres.
	Alfanumérico y caracteres especiales cuáles son: ~!@#$%^&*()_-+={}[];:'"<>,./?\|Ññ
Integridad de la BD.
	Crear restricciones en la BD para mantener la integridad de la lógica del negocio.
	Crear Backups mediante TRIGERRS, PROCEDURES o manualmente.
	Tener bien administrados los usuarios y sus permisos para evitar pérdida, fuga o alteración de las BDs.
Optimización de la BD.
	Escoger el modelo de datos idóneo para la BD.
	Respetar las reglas de dicho modelo de datos, para evitar redundancias innecesarias, ambigüedad en la estructura, etc.
	Utilizar los tipos de datos primitivos y estándar, para que se pueda garantizar la posibilidad de una migración.
		Si es para el modelo relacional, utilizar los tipos primitivos, Numéricos, Tiempos y Texto, cuáles son respectivamente:
		NUMERIC(<entero>,<decimal>), DATE, CHAR(<longitud>), VARCHAR(<longitud>)
		Ejemplos y con sus CONSTRAINTs necesarios:
			Si es el año de creación:
				anioCreacion NUMERIC(4,0)
				CONSTRAINT ckAnioCreacion CHECK (anioCreacion >= 2000)
				Del año 2000 hasta el 9999.
			Si es una calificacion:
				calificacion NUMERIC(3,1)
				CONSTRAINT ckCalificacion CHECK (calificacion >= 0.0)
			Fecha de nacimiento:
				fechaNacimiento DATE
			Código postal:
				cp CHAR(10)
			Apellido paterno:
				paterno VARCHAR(15)

Norma: Describe la necesidad de una actividad de un DBA, son mas detalladas y especificas que las políticas. Para evaluar la calidad de la actividad.
	Passwords debe ser minimo de 8 caracteres.
	Maximo de 12 caracteres.
	No caracteres especiales.
	3 n por cada p

Procedimiento: Instrucciones que describen una serie de pasos a seguir durante la operación de una actividad determinada.
	El usuario final envia al DBA una solicitud por escrito para la creación de una cuenta.
	El DBA aprueba la solicitud y la envia al operador de la computadora.
	1 p relacionado con alguna p o n

Politica, n y p que abarcan campos de actividad como son:
	Diseño y modelado de una bd.
	Documentación y operación de una bd.
	Mantenimiento y operación de una bd.
	Seguridad e integridad
	Respaldo y recuperación

Funciones del DBA
	Los procedimientos y normas deben revisarse y modificarse al menos cada año.
	Extensión lógica de sus actividades administrativas.
	Los aspectos tecnicos del trabajo del DBA son en las siguientes areas:
		Evaluar, seleccionar e instalar el DBMS y utilerias necesarias
	Extensión lógica de sus actividades administrativas.
	Los aspectos técnicos son las siguientes areas:
		Evaluar: seleccionar e instalar el DBMS t utilerias relacionadas.
		Diseñar e implementar BDs y apps.
		Probar y evaluar BDs y apps.
		Mantener el DBMS, utilerias y apps.
	De acuerdo con las fases del ciclo de vida de una BD:
		Adquisición del SGBD
		Planeación de las BD, incluida la definición de estándares, procedimientos y ejecución.
		Obtención de requerimientos de datos persistentes.
		Diseño conceptual, lógico y físico.
		Implementación de BD.
		Pruebas de la BD.
		Operación y mantenimiento de BD.
		Instalación del SGBD.
		Incluida la migración.
	Importante saber usar herramientas de ayuda que proporcionan tanto de las herramientas de su SGBD asi como la documentación oficial.
	Administrar el SGBD no es facil, pero la experiencia permitira la formación completa del DBA.

Usuarios:
	DBA
	Diseñador de la BD
	Programador
	Usuarios finales

Areas de trabajo: Cualquier organización donde se desarrollen sistemas o apps con acceso a datos.
	Sector educativo, bancario, medico, seguros, etc.

Administrador del server
~# sudo apt-get check

Instalación de PostgreSQL en Linux xD:
~# sudo su
~# wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add
~# sudo echo "deb http://apt.postgresql.org/pub/repos/apt/ 'lsb_release –cs'-pgdg main" | sudo tee /etc/apt/sources.list.d/pgdg.list
~# sudo apt update
~# sudo apt upgrade
~# sudo apt-get install postgresql
~# ps aux | grep postgresql
~# sudo apt install curl
~# curl https://www.pgadmin.org/static/packages_pgadmin_org.pub | sudo apt-key add
~# sudo sh -c 'echo "deb http://apt.postgresql.org/pub/repos/apt/ $(lsb_release -cs)-pgdg main" >> /etc/apt/sources.list.d/pgdg.list'
~# sudo apt install postgresql postgresql-client postgresql-contrib libpq-dev
~# ps aux | grep postgres
~# sudo mkdir -p /etc/apt/sources.list.d/
~# sudo echo "deb https://ftp.postgresql.org/pub/pgadmin/pgadmin4/apt/focal/ pgadmin4 main" > /etc/apt/sources.list.d/pgadmin4.list
~# sudo apt install pgadmin4


https://noviello.it/es/como-instalar-pgadmin4-en-ubuntu-20-04-lts/
~# curl https://www.pgadmin.org/static/packages_pgadmin_org.pub | sudo apt-key add -
	~# sudo sh -c 'echo "deb https://ftp.postgresql.org/pub/pgadmin/pgadmin4/apt/focal pgadmin4 main" > /etc/apt/sources.list.d/pgadmin4.list'
~# sudo sh -c 'echo "deb https://ftp.postgresql.org/pub/pgadmin/pgadmin4/apt/$(lsb_release -cs) pgadmin4 main" > /etc/apt/sources.list.d/pgadmin4.list'
~# sudo apt update
~# sudo apt install pgadmin4
~# sudo /usr/pgadmin4/bin/setup-web.sh





7. Ajustes de configuración de rendimiento:
Todos los DBMS cuentan con parámetros configurables que mejoran su rendimiento: Cantidad de caché, máximo de usuarios contectados, etc.

En PostgreSQL el archivo de configuración es /etc/postgresql/12/main/pg_hba.conf
SHOW hba_file;

/etc/postgresql/12/main/postgresql.conf
	port: Puerto
	max_connections: Total de conexiones
	shared_buffers: Determina el número de bloques de memoria/buffers que PostgreSQL reservará, como zona de trabajo, en el momento del arranque para procesar las consultas y mantener datos en cache.
		Se recomienda minimo el 25% y maximo el 40% de RAM.
	¿Porque esa cantidad? Si un Linux es muy ligero. =======================
		Depende de los datos almacenados en la BD y del tipo de consultas que se hacen.
	work_mem: Memoria temporal utilizada por cada sesión, para las operaciones de ordenamiento (ORDER BY), las sesiones de diferenciación (GROUP BY, HAVING y DISTINCT), y para gestión de hash (uniones HASH, indices HASH, hash_aggregations), si realizamos muchísimas consultas ordenadas, agrupadas, diferenciadas por cadenas, etc., se crearán mucho de estos buffers de manera paralela, mientras más memoria asignemos, menos probabilidades hay que los ordenamientos y otras operaciones se hagan con archivos temporales en disco (más lentos que la RAM).
	Regla: Consultas con poca concurrencia se asigna 2% - 4% de RAM disponible.
		Con alta concurrencia deja el valor por defecto.
		Cada consulta consume la misma cantidad de RAM: 4Gb el 4% es 163 MB
		work_mem=163
	temp_buffers: Memoria temporal utilizada por cada sesión para las tablas temporales y para la apertura de tablas en cada sesión para cada BDs.
		Este valor depende de la cantidad de datos que carga cada sesión y del hardware que se utiliza.
		Valor default 8MB, pero se puede cambiar a 16MB.
	shared_preload_libraries = '$libdir/plpython2.so'
		Permite cargar una biblioteca específica cuando arranca el sistema, si utiliza muchos procedimientos almacenados en un lenguaje especificado (Python, Perl, Tcl, Java, etc.), es bueno pre-cargarla para que esté disponible cuando se utilice por primera vez.
		Nota: esta opción ralentiza un poco el reinicio del sistema.
	bgwriter_delay = 500ms
		Es un proceso del servidor que se enarga de escribir a disco todos los "shared_buffers" modificados, este proceso conlleva una carga de I/O sobre el disco, su modificación permite o reducir el valor para evitar en lo más posible pérdidas de datos en equipos que pueden fallar, o su incremento permite reducir el I/O al disco duro en sistemas perfectamente protegidos.
	vacuum_cost_delay: PostgreSQL determina el tiempo que vacuum dormirá luego de haber trabajado por un cierto periodo.
		Hacer uso de este parámetro puede evitar que un vacuum consuma demasiados recursos procesando una tabla muy grande y/o con alta concurrencia. Y ser utilizados por otro proceso o aplicación.
El sitio web https://pgtune.leopard.in.ua/#/ para generar un contenido (recomendado) para el archivo de configuración "/etc/postgresql/12/main/postgresql.conf".

8. Optimización de consultas
Si las BD no estan hasta la 3era forma normal. Esto puede afectar de forma radical la velocidad de la BD.

Regla: Conocer y aplicar por lo menos las primeras 3 formas normales.

Después de la tercera se usan para hacer aún más rápida la BD, y es función de los Administradores con profundo conocimiento del funcionamiento del motor de BD.

Regla: Si la consulta toma más de un segundo, hay que optimizarla.

Una consulta correctamente escrita y optimizada puede significar un ahorro de recursos aun cuando nosotros solo veamos segundos de diferencia.

Errores comunes que afectan para que una consulta sea optima:
	Sobre utilización de subconsultas: Es de alto impacto para el rendimiento de nuestra BD.
		Solo utilizarlas cuando sean necesarias.
	Tener tablas donde con n cantidad de columnas y solo algunas columnas en concreto son utilizadas de manera continua.
	Utilizar SELECT * para cualquier consulta aun cuando no necesariamente se ocupen todas las columnas.
	Abuso de índices: Por regla general se crean índices sobre campos que se seleccionan, agrupan y ordenan a menudo.
		El problema es que es que cada índice ocupa un espacio proporcional al número de filas en la tabla.
	Uso excesivo de las búsquedas de texto en cadenas, especialmente usando el %.
		LIKE %

Soluciones:
	Evitar las subconsultas, si existe otro camino.
	NOTA: Por regla general, convertir un SELECT anidado en un JOIN fácilmente.
	Limitar las consultas a las columnas que se necesitan.
	Los datos que son usados frecuentemente se mantienen en otra tabla mientras que los que se usan con menos frecuencia se dejan en otra evitando asi que la tabla menos frecuente ocupe menos memoria.
	Crear índices estrictamente necesarios.
	Evitar el LIKE %.

Los procedimientos almacenados son una alternativa rápida y mejor a las consultas por las siguientes razones:
	1. Los procedimientos almacenados son compilados, dependiendo del RDBMS, como lo implemente, (el código SQL es interpretado) haciéndolas una opción mucho más rápida.
	2. El ahorro de ancho de banda es importante pues se pueden realizar varias consultas en un mismo procedimiento, además el procedimiento se mantiene en el servidor hasta que el resultado final es obtenido, y es esto únicamente lo que se envía al cliente.
Min 1:07:23














CMD:
psql -U postgres
\conninfo --Info de la conexion
\?
\h [comando] --Muestra la sintaxis de un comando o lista todos los comandos
\encoding --Muestra codificacion de la consola
\l --Lista BDs
\c --Cambia a una BD
\d [tabla] --Muestra las tablas de la BD o la estructura de una tabla
\i <script> --Ejecuta el script
\o <rutaSalida> --Guarda los resultados en el archivo de salida
C:\Program Files\PostgreSQL\14\bin> pg_ctl -D "C:\Program Files\PostgreSQL\14\data" {stop|start|restart}
C:\Program Files\PostgreSQL\14\bin> pg_ctl --help


\password --Cambiar el password de PostgreSql
/var/lib/postgresql/14/main --Carpeta de los binarios
~# sudo -u postgres psql -c "SHOW data_directory;" --Carpeta de las BDs
~# systemctl {status|stop|start|restart|reload|is-active} postgresql.service


3. Administración del Catalogo
Definir una BD involucra especificar los tipos de datos, estructuras y restricciones de los datos o ser almacenados en la base la definición descriptiva de la BD es también almacenada por el DBMS en forma de un catalogo.
El catalogo consiste en el conjunto de tablas de sistema que guardan información sobre los objetos de la BD.
Por lo que en el catalogo se puede encontrar una tabla que describe los datos de todas las tablas de usuario, también una tabla que describe los datos de las BDs, otra tabla que describe los usuarios, etc.
La información almacenada en el catalogo se denomina meta-datos. Su principal utilidad es la de conocer que datos existen sin acceder a ellos.

Dado que son tablas, es posible hacer consultas.
pg_constraint, pg_database, pg_group, pg_indexes, pg_tables, pg_user, pg_class, pg_roles, pg_language

\dS --Muestra los catalogos del sistema
SELECT name, setting FROM pg_settings WHERE category = 'File Locations';
SELECT VERSION(); --Funcion de agregado que retorna la version de PostgreSql

SELECT * FROM pg_database;
SELECT datname,datcollate FROM pg_database;
SELECT datname,datconnlimit FROM pg_database;
SELECT * FROM pg_class;
SHOW server_encoding;
SHOW client_encoding;
SET CLIENT_ENCODING TO 'LATIN2';
SET SERVER_ENCODING TO 'UTF8';
SELECT * FROM pg_roles;
CREATE ROLE usuario1 CREATEDB;
SELECT rolname,rolcreatedb FROM pg_roles WHERE rolcreatedb = '1';
SELECT lanname FROM pg_language;
ALTER USER postgres WITH password 'postgres';
ALTER ROLE usuario1 WITH CREATEDB CREATEROLE;
CREATE USER usuario2 PASSWORD 'usuario2' SUPERUSER CREATEDB CREATEROLE;

SELECT pg_size_pretty(pg_database_size('empleados'));
SELECT pg_size_pretty(pg_total_relation_size('cargo'));
\timing --Tiempo de ejecucion de una consulta, se activa/desactiva
SELECT relname,relpages FROM pg_class ORDER BY relpages DESC; --Tablas mas grandes


--Super usuarios:
SELECT oid,rolname,rolsuper FROM pg_authid;
--Creadores de roles:
SELECT oid,rolname,rolcreaterole FROM pg_authid;
--Creadores de BD:
SELECT oid,rolname,rolcreatedb FROM pg_authid;
--Quienes se logean:
SELECT oid,rolname,rolcanlogin FROM pg_authid;
--Quienes tienen password:
SELECT oid,rolname,rolpassword FROM pg_authid;
--Clave de la BD:
SELECT oid,datname,datcollate FROM pg_database;
--El idioma de la BD:
SELECT datname,datcollate FROM pg_database;
--Máximo de conexiones a la BD:
SELECT datname,datconnlimit FROM pg_database;
--Codificación de la BD:
SELECT datname,encoding FROM pg_database;
--El espacio de tabla predeterminado para la base de datos.
SELECT datname,dattablespace FROM pg_database;
--Clave de las tablas, indices, secuencias, vistas (relaciones)
SELECT oid,relname FROM pg_class;
--Clave que la relación contiene
SELECT oid,relname,relnamespace FROM pg_class;
--Propietario de la relación
SELECT oid,relname,relowner FROM pg_class;
--Tamaño de la representación en disco de esta tabla en páginas
SELECT oid,relname,relpages FROM pg_class;
--Numero de tuplas de la relación
SELECT oid,relname,reltuples  FROM pg_class;
--Clave del lenguaje
SELECT oid,lanname FROM pg_language;
--Lenguaje interno como SQL
SELECT lanname,lanispl FROM pg_language;
--Propietario del lenguaje
SELECT lanname,lanowner FROM pg_language;
--Si es un lenguaje confiable, que no otorga acceso a nada fuera del entorno normal de ejecución de SQL:
SELECT lanname,lanpltrusted  FROM pg_language;
--Para los idiomas no internos, esto hace referencia al controlador de idiomas, que es una función especial que es responsable de ejecutar todas las funciones que están escritas en el idioma en particular. Cero para idiomas internos.
SELECT lanname,lanplcallfoid FROM pg_language;

3.1. Tablas del sistema
3.2. Vistas del sistema




5. Monitoreo del sistema
Vigilar el funcionamiento de un sistema, servicio o actividad.

Elementos comunes a tomar en cuanto para el monitoreo:
Servidor: Disponibilidad y posibles problemas del hardware
CPU: Carga del sistema y uso de la CPU
Memoria: Carga y uso de la RAM y la Swap
Red: Disponibilidad de los componentes de red, trafico de entrada y salida
Disco/almacenamiento: Espacio utilizado
PostgreSQL: Numero de conexiones, numero de transacciones, transacciones, bloqueo, espacio usado, etc.

Los objetivos son:
Verificar el consumo de recursos
Actividad positiva del mismo
Tiempo de respuesta del servidor
Recabar la mayor cantidad de información, a fin de poder tener los suficientes datos para ubicar donde esta el problema
Detección de problemas de red
Obtener información de una determinada tarea o consulta  (especial para puesta a punto de sentencias o servidor).

Formas de monitoreo: S.O. y el manejador de bases de datos
~# ps aux | egrep 'postgres'
~# vmstat --Muestra estadisticas del sistema, permite obtener un detalle general de los procesos, E/S, uso de RAM/SWAP, CPU, estados del sistema. Puede ser utilizado para ayudar a identificar cuellos de botella en el rendimiento.
~# vmstat 2 10 --Cada 2 segundos muestra datos, durante 10 segundos
~# vmstat 2 --Infinito
~# top
~# htop
~# bashtop
~# gotop --https://github.com/cjbassi/gotop
~# netstat -ntu|grep "TIME_WAIT"|wc -l
-p --Puertos
-u --Puertos udp
-t --Puertos tcp
-o --Timers
-n --Numero de puerto
-a --Conexiones activas
~# ps f -o pid,ppid,args -C postgres
~# iostat
~# iostat -d 2
~# iostat -p sda
~# free
-b bytes
-k kigabytes
-m megabytes
-g gigabytes
-t total
~# lscpu
~# mpstat
~# netstat | grep 5432
~# cat /proc/cpuinfo

Ver consultas actuales corriendo:
SELECT pg_stat_get_backend_pid(s.backendid) as procpid, pg_stat_get_backend_activity(s.backendid) as current_query FROM (SELECT pg_Stat_get_backend_idset() as backendid) AS s;

SELECT * FROM pg_stat_activity;
Actividad del usuario postgres
empleados=# SELECT datname FROM pg_stat_activity WHERE usename = 'postgres';

Muestra información sobre todos los procesos en ejecución
postgres=# SELECT usename,application_name,state FROM pg_stat_activity;

Muestra las conexiones de los clientes:
SELECT datname,usename,client_addr,client_port FROM pg_stat_activity;





4. Importación y exportación de datos
Importar: traer de otra parte algo, incorporar datos que fueron creados en otra app o RDBMS distinto o versiones anteriores.
COPY <tabla> FROM {<direccion>|<archivo>} WITH DELIMITER;
	FORMAT: tipo de archivo
	DELIMITER: separador de columnas (| o ,)
	NULL: cadena que representa el valor nuli
	HEADER: indica si la primera linea contiene encabezados (formato CSV)
	QUOTE: caracter usado para citar texto/valores

Exportar:

mv DATOS.sql /var/lib/postgresql/
mv CREAB_BD_EMPLEADO.sql /var/lib/postgresql/
cd /var/lib/postgresql/
sudo su postgres
psql
CREATE DATABASE misempleados;
\c misempleados;
\i CREAB_BD_EMPLEADO.sql;
\i DATOS.sql;
exit
cat > datos_copy.txt
7,Vendedor
8,Marketing
9,Logistica
cat datos_copy.txt
misempleados=# COPY cargo FROM misempleados/datos_copy.txt WITH DELIMITER ',';
exit
cat > empleado_copy.txt
id_empleado,nombre,apaterno,amaterno,edad,sexo,sueldo,comision,fecha,departamento,cargo
20,MIGUEL,TORRES,JUAREZ,21,M,20000,20,2019-02-04,2,4
cat empleado_copy.txt
psql
\c misempleados;
COPY empleado FROM '/var/lib/postgresql/empleado_copy.txt' WITH (FORMAT csv, HEADER, DELIMITER ',');
exit
psql
cat > empleado_copy2.txt
id_empleado,nombre,apaterno,amaterno,edad,sexo,sueldo,departamento,cargo
21,JULIA,PEREZ,CAMARGO,25,M,20000,2,4
cat empleado_copy2.txt
psql
\c misempleados;
COPY empleado (id_empleado,nombre,apellido_paterno,apellido_materno,edad,sexo,sueldo,id_departamento,id_cargo) FROM '/var/lib/postgresql/empleado_copy2.txt' WITH (FORMAT csv, HEADER, DELIMITER ',');
exit
cat > datos_comillas.txt
"11","Ayudante"
cat datos_comillas.txt
psql
\c misempleados;
COPY cargo (id_cargo,nombre) FROM '/var/lib/postgresql/datos_comillas.txt' WITH (FORMAT csv, DELIMITER ',', QUOTE '"');
--COPY <tabla> TO '<nuevoArchivo>' WITH DELIMITER ',';
COPY cargo TO '/var/lib/postgresql/datos_exp.csv' WITH DELIMITER ',';
--COPY cargo TO 'C:\Users\oscar\Downloads\DiploBD\Modulo5\datos_exp.csv' WITH DELIMITER ',';
COPY cargo TO '/var/lib/postgresql/datos_exp2.csv' WITH (FORMAT csv, HEADER);
COPY (SELECT nombre FROM cargo WHERE nombre LIKE 'M%') TO '/var/lib/postgresql/datos_exp4.csv' WITH (FORMAT csv, HEADER);
COPY cargo TO '/var/lib/postgresql/datos_exp3.csv' WITH (DELIMITER E\'t');
COPY (SELECT nombre FROM cargo WHERE nombre LIKE 'M%') TO '/var/lib/postgresql/datos_exp5.csv' WITH (DELIMITER E\'t');













6. Programación de tareas rutinarias
~$ pg_dump misempleados > resmisempleados.sql
CREATE DATABASE misempleados_res;
~$ psql misempleados_res < resmisempleados.sql
analyze; --Analiza la BD
vacuum analyze; --Limpia la BD
REINDEX DATABASE misempleados; --Vuelve a hacer el indice de las tablas

sudo cat > /etc/cron.d/postgresmicron
45 4 * * * root nice -n 19 su - postgres -c "pg_dumpall --clean" | gzip -9 > /var/lib/postgresql/postgres_all.sql.gz
* * * * 0 root nice -n 19 su - postgres -c "vacuumdb --all --full –analyze"
45 3 * * 1-6 root nice -n 19 su - postgres -c "vacuumdb --all --analyze --quiet"
0 3 * * 0 root nice -n 19 su - postgres -c 'psql -t -c "select datname from pg_database order by datname;" | xargs -n 1 -I"{}" -- psql -U postgres {} -c "reindex database {};"'






















Raul Alejandro Ojeda Ramirez
raul_ojeda@comunidad.unam.mx

MÓDULO VI
SEGURIDAD DE BASES DE DATOS
1. Seguridad
1.1. Esquemas de acceso a servidores de bases de datos
1.2. Administración de usuarios
1.3. Administración de grupos
1.4. Administración de roles
1.5. Administración de privilegios
1.6. Restricciones de acceso al servidor
2. Respaldos
2.1. Generación automática de scripts
2.2. Creación de respaldos
2.3. Restauración de respaldos
3. Desarrollo de planes de contingencia

20% Participación y/o actividades
30% Tareas
50% Exámenes

Seguridad: Protección ante cualquier amenaza o acción maliciosa.

Privacidad: La seguridad en BD es un mecanismo fundamental ya que todo sistema esta expuesto a cualquier tipo de amenazas de daño, enormes y desastrosas como pequeñas y leves pero que de una manera u otra causan perdida de confidencialidad.
Se puede medir en:
* La protección del sistema frente a ataques externos.
* La protección frente a caídas o fallos en el software o en el equipo.
* La protección frente a manipulación por parte de usuarios no autorizados.

Medidas de seguridad:
* Físicas: Controlar el acceso al equipo. Tarjetas de acceso, etc.
Personal: Acceso sólo del personal autorizado. Evitar sobornos, etc.
S.O: Seguridad a nivel del S.O.
Herramientas de seguridad, perfiles de usuario, vistas, restricciones de uso de vistas, etc.

Hay 2 tipos de seguridad:
* Direccional: Se usa para otorgar y revocar privilegios a los usuarios a nivel de archivos, registros o campos en un modo determinado (consulta o modificación). El DBA puede otorgar o revocar privilegios a otros usuarios en la forma de consulta (SELECT), modificación o refencias. A través del uso de la instrucción (GRANT OPTION).
* Obligatoria: Sirve para imponer seguridad de varios niveles tanto para los usuarios como para los datos.

Tipos de usuarios:
* Con derecho a crear, borrar y modificar objetos y que además puede conceder privilegios a otros usuarios sobre los objetos que ha creado.
* Con derecho a consultar, o actualizar, y sin derecho a crear o borrar objetos. Privilegios sobre los objetos, añadir nuevos campos, indexar, alterar la estructura de los objetos, etc.

Identificación y Autentificación:
* Código y Contraseña
* Identificación por hardware
* Conocimiento, aptitudes y hábitos del usuario
* Información predefinida (Aficiones, cultura...)

El DBA deberá especificar los privilegios que un usuario tiene sobre los objetos:
* Usar una BD
* Consultar ciertos datos
* Actualizar datos
* Crear o actualizar objetos
* Ejecutar procedimientos almacenados
* Referenciar objetos
* Indexar objetos
* Crear identificadores

Esquema: Representa la configuración lógica de todo o parte de una BD relacional. Puede existir de 2 formas: como representación visual y como un conjunto de fórmulas conocidas como restricciones de integridad que controlan una BD. Indica cómo las entidades que conforman la BD se relacionan entre sí, incluidas las tablas, las vistas, los procedimientos almacenados.
Database
               ┌────────┬─────────┐
Schema owners  │  USER1 │  USER2  │
               ├────────┼─────────┤
Schema objects │  test  │  test   │
               │ table5 │ table1  │
               │ table7 │ table15 │
               └────────┴─────────┘

Agrupación o permisos prestablecidos.

En PostgreSQL, una BD contiene uno o más schemas, los cuales contienen tablas. Pero también pueden contener otros tipos de objetos como tipos de datos, funciones y operadores. Los nombres se pueden repetir entre schemas, por ejemplo dos schemas diferentes pueden contener cada uno su propia tabla llamada "usuario". Pero a diferencia de las BDs, los schemas no están separados de manera rígida: un usuario puede acceder a objetos pertenecientes a cualquiera de los schemas de la BD a la cual están conectados.

CREATE DATABASE modulo6;
\c modulo6;
CREATE SCHEMA myEsquema;
DROP SCHEMA myEsquema;

Permisos de los objetos
* Owner: Cuando se crea un objeto de BD, se le asigna un owner (generalmente es quién ejecuta la sentencia de creación), por ejemplo CREATE DATABASE db_name. A este owner, Postgres le asigna por defecto todos los permisos sobre ese objeto.
* Public: Existe el pseudo-rol o palabra clabe Public, que se puede entender como un grupo que contiene a todos los usuarios de la instancia. Por defecto, este grupo tiene ciertos privilegios sobre los objetos de la BD, como ser: CONNECT y TEMPORARY (crear tablas temporales) para las BDs, EXECUTE para las funciones y USAGE para los lenguajes y tipos de datos. Nota: no se asginan privilegios por defecto a Public para tablas, columnas, esquemas, secuencias, foreign data wrappers, foreign servers o large objects.

Public: Indica que los privilegios deben otorgarse a todos los roles, incluidos los que prodrían crearse más adelante. Public se puede considerar como un grupo implícitamente definido que siempre incluye todos los roles. Cualquier directamente a él, los privilegios otorgados a cualquier rol al que actualmente pertenece y los privilegios otorgados a Public.
PostgreSQL otorga privilegios predeterminados en algunos tipos de objetos a Public. No se otorgan privilegios a Public de forma predeterminada en tablas, columnas de tabla, secuencias, contenedores de datos externos, servidores extranjeros, objetos grandes, esquemas o espacios de tabla. Para otros tipos de objetos, los privilegios predeterminados otorgados a Public son los siguientes: privilegios CONNECT y TEMPORARY (crear tablas temporales) para BDs; Privilegio EXECUTE para funciones; y privilegio de USAGE para idiomas y tipos de datos (incluidos los dominios).

Creación de usuarios
CREATE USER <name> [ [ WITH ] option [...] ]
where option can be:
	SYSID <uid>
	| CREATEDB | NOCREATEDB
	| CREATEUSER | NOCREATEUSER
	| IN GROUP <groupName> [, ...]
	| [ ENCRYPTED | UNENCRYPTED ] PASSWORD '<password>'
	| VALID UNTIL '<abstime>';

Ejecutar:
CREATE USER appweb01 WITH PASSWORD 'appweb01';
CREATE USER dba01 WITH PASSWORD 'dba01';
CREATE USER data01 WITH PASSWORD 'data01';
--Muestra los  usuarios creados
\du
\dg
SELECT * FROM pg_user;

Controlar permisos en PostgreSQL. GRANT & REVOKE
* Los RDBMS como Oracle, MySQL, SqlServer o PostgreSQL implementan una serie de comandos SQL que permiten al administrador controlar el acceso a los objetos de una DB.
* Estos comandos SQL son proporcionados por el lenguaje SQL, más concretamente por el DCL (lenguaje de control de datos).

GRANT
Tiene dos variantes básicas: una que otorga privilegios a un objeto de la BDs (tabla, columna, vista, tabla externa, secuencia, BDs, contenedor externo de datos, servidor externo, función, lenguaje de procedimientos, esquema o espacio de tabla) y uno que otorga membresía en un rol.

Sintaxis Grant
GRANT {{SELECT|INSERT|UPDATE|DELETE|TRUNCATE|REFERENCES|TRIGGER}[,...]|ALL [PRIVILEGES]}
	ON {[TABLE] <table_name> [,...]|ALL TABLES IN SCHEMA <schema_name> [,...]}
	TO <role_specification> [,...] [WITH GRANT OPTION];

Privilegios que otorga Grant
* SELECT. Permite consultar cualquier columna de tabla, vista o secuencia especificada.
* INSERT. Permite insertar registros en la tabla especificada.
* UPDATE. Permite actualizar cualquier columna de la tabla especificada.
* DELETE. Permite eliminar registros de la tabla especificada.
* REFERENCES. Para poder crear una clave foránea es necesario tener este privilegio sobre ambas tablas de la relación.
* TRIGGER. Permite la creación de triggers sobre la tabla especificada.
* CREATE. Para BDs, permite crear nuevos esquemas dentro de la misma. Para esquemas, permite la creación de nuevos objetos dentro del mismo.
* CONNECT. Permite a los usuarios especificados conectarse a una BD determinada.
* TEMPORARY o TEMP. Permite crear tablas temporales para la BD especificada.
* EXECUTE. Permite utilizar la función especificada. Este es el único privilegio para tratar funciones.
* USAGE. Para lenguaje procedimental, permite el uso del mismo para la creación de funciones.
* ALL PRIVILEGES. Garantiza todos los privilegios disponibles.
Tablas Temporales son los procedimientos almacenados.

REVOKE
* Con este comando eliminamos los privilegios otorgados o los que ya tenían por defecto los roles.
REVOKE <privilegio> ON <table> FROM <rol>;

Algunos privilegios y sus significados:
* a: Permiso de INSERT a append
* r: Permiso de SELECT o read
* w: Permiso de UPDATE o write
* d: Permiso de DELETE o delete
* D: Permiso de 
* x: Permiso de REFERENCES
* t: Permiso de TRIGGER
postgresql.org/docs/8.3/sql-grant.html

Ejecutar:
Logearse como postgres:
CREATE TABLE tabla01 (id INTEGER, nombre VARCHAR(20));
GRANT SELECT ON tabla01 TO data01;
--Lista los privilegios otorgados sobre los objetos
\dp
\z

Logearse desde el inicio con data01:
\c modulo6
SELECT * FROM tabla01;
 id | nombre
----+--------
(0 filas)


modulo6=> INSERT INTO tabla01 VALUES (1,'1');
ERROR:  permiso denegado a la tabla tabla01

En postgres:
\c modulo6;
GRANT INSERT (id) ON tabla01 TO appweb01;
GRANT UPDATE (id), INSERT (nombre) ON tabla01 TO dba01;
--Comprobar
\z
                                             Privilegios
 Esquema | Nombre  | Tipo  |        Privilegios        | Privilegios de acceso a columnas | PolÝticas
---------+---------+-------+---------------------------+----------------------------------+-----------
 public  | tabla01 | tabla | postgres=arwdDxt/postgres+| id:                             +|
         |         |       | data01=r/postgres         |   appweb01=a/postgres           +|
         |         |       |                           |   dba01=w/postgres              +|
         |         |       |                           | nombre:                         +|
         |         |       |                           |   dba01=a/postgres               |
(1 fila)
REVOKE INSERT (id) ON tabla01 FROM appweb01;
\z
ALTER USER dba01 SUPERUSER;
\du
                                     Lista de roles
 Nombre de rol |                         Atributos                          | Miembro de
---------------+------------------------------------------------------------+------------
 appweb01      |                                                            | {}
 data01        |                                                            | {}
 dba01         | Superusuario                                               | {}
 postgres      | Superusuario, Crear rol, Crear BD, Replicaci¾n, Ignora RLS | {}

Crear un usuario de sólo lectura en PostgreSQL (sin permiso alguno)
* Ahora creemos un usuario:
CREATE USER pruebauser WITH PASSWORD 'pruebauser';
* Por seguridad, revocamos los permisos al public para que ningún usuario tenga 
REVOKE ALL ON DATABASE modulo6 FROM public; --Solo para futuros usuarios

Crear un usuario de sólo lectura en PostgreSQL
* Se asigna el permiso para conectarse a la BD:
CONNECT ON DATABASE modulo6 TO pruebauser;
* El usuario ya puede conectarse a la BD, pero cuidado, el public tiene permisos por defecto sobre el esquema público, con lo cual, el usuario puede crear estructuras e insertarle datos. Quitemos los permisos al public y asignemos permisos USAGE al usuario para que pueda ver los objetos del esquema.
REVOKE ALL ON SCHEMA public FROM public;
GRANT USAGE ON SCHEMA public TO pruebauser;

Crear un usuario de sólo lectura en PostgreSQL
* Ahora se le da permisos para consultar todas las tablas (incluye vistas) EXISTENTES en la BD (suponiendo que estamos en el esquema public):
GRANT SELECT ON ALL TABLES IN SCHEMA public TO pruebauser;
Se especifica al motor que, en cada objeto nuevo que se cree se otorguen los privilegios:
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT ON TABLES TO pruebauser;

Permisos de escritura
* Creamos una tabla:
CREATE TABLE usuarios (nombre VARCHAR(30), clave VARCHAR(10));
* Se asignan los permisos a la tabla con el usuario prueba;
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE usuarios TO pruebauser;
* Con el siguiente comando se quitan los permisos:
REVOKE SELECT, INSERT, UPDATE, DELETE ON TABLE usuarios FROM pruebauser;

Un usuario tiene permisos.
Un grupo puede tener un rol.
Un rol puede tener un rol.
Un rol tiene permisos.

Tarea
5 de GRANT
5 de REVOKE
Conectarse a 4 usuarios para corroborar los permisos anteriores.
Word con caratula
Rojas Castillo Oscar - Modulo 6 - Tarea 1
Martes 21

CREATE USER user1 WITH PASSWORD 'user1';
CREATE USER user2 WITH PASSWORD 'user2';
CREATE USER user3 WITH PASSWORD 'user3';
CREATE USER user4 WITH PASSWORD 'user4';

SELECT oid,rolname,rolsuper FROM pg_authid;

CREATE DATABASE database1; --SELECT, INSERT
CREATE DATABASE database2; --UPDATE
CREATE DATABASE database3; --DELETE
CREATE DATABASE database4; --TRUNCATE

\c database1;
CREATE TABLE tabla11 (idTabla11 NUMERIC(2,0) NOT NULL, CONSTRAINT pkTabla11 PRIMARY KEY (idTabla11));
\c database2;
CREATE TABLE tabla21 (idTabla21 NUMERIC(2,0) NOT NULL, CONSTRAINT pkTabla21 PRIMARY KEY (idTabla21));
INSERT INTO tabla21 VALUES(1);
\c database3;
CREATE TABLE tabla31 (idTabla31 NUMERIC(2,0) NOT NULL, CONSTRAINT pkTabla31 PRIMARY KEY (idTabla31));
INSERT INTO tabla31 VALUES(1);
\c database4;
CREATE TABLE tabla41 (idTabla41 NUMERIC(2,0) NOT NULL, CONSTRAINT pkTabla41 PRIMARY KEY (idTabla41));
INSERT INTO tabla41 VALUES(1);

\c database1;
REVOKE ALL ON tabla11 FROM user1; REVOKE ALL ON tabla11 FROM user2; REVOKE ALL ON tabla11 FROM user3; REVOKE ALL ON tabla11 FROM user4;
\c database2;
REVOKE ALL ON tabla21 FROM user1; REVOKE ALL ON tabla21 FROM user2; REVOKE ALL ON tabla21 FROM user3; REVOKE ALL ON tabla21 FROM user4;
\c database3;
REVOKE ALL ON tabla31 FROM user1; REVOKE ALL ON tabla31 FROM user2; REVOKE ALL ON tabla31 FROM user3; REVOKE ALL ON tabla31 FROM user4;
\c database4;
REVOKE ALL ON tabla41 FROM user1; REVOKE ALL ON tabla41 FROM user2; REVOKE ALL ON tabla41 FROM user3; REVOKE ALL ON tabla41 FROM user4;

\z
\c database3;
\z
\c database2;
\z
\c database1;
\z

GRANT SELECT
	ON TABLE tabla11
	TO user1;
\z
GRANT INSERT (idTabla11)
	ON TABLE tabla11
	TO user1;
\z
\c database2;
GRANT UPDATE (idTabla21)
	ON TABLE tabla21
	TO user2;
\z
\c database3;
GRANT DELETE
	ON TABLE tabla31
	TO user3;
\z
\c database4;
GRANT TRUNCATE
	ON TABLE tabla41
	TO user4;
\z



Comandos importantes
Para cambiar la contraseña de un usuario:
ALTER ROLE <usuario> WITH PASSWORD '<password>';
Asignar todos los permisos a un usuario a una BD:
GRANT ALL PRIVILEGES ON DATABASE <bd> TO <usuario>;
Verificar que usuario es:
SELECT current_user;
Listar los privilegios sobre los schemas de una bd:
\dn
\dn+ -- + da los permisos de la lista ACL
Listar los esquemas:
SELECT nspname FROM pg_catalog.pg_namespace;

Administración de grupos:
La administración de grupos de usuarios. Permite a los administradores organizar los privilegios de seguridad de los usuarios como parte de Grupos. El administrador establece los privilegios de seguridad del grupo y asigna los usuarios a grupos.
* Un administrador puede crear, cambiar el nombre y eliminar grupos, así como modificar la pertenecia a grupos.
* Un grupo puede contener usuarios o incluso otros grupos.
* Tanto un usuario como un grupo pueden pertenecer a varios grupos.

La pertenecia a grupos facilita la administración de la seguridad de muchos usuarios ya que no tienen que administrar de forma individual los privilegios de cada usuario:
* Si se aplica una restricción de seguridad a un grupo, esta restricción se aplica de forma implícita a todos los miembros de ese grupo.
* Si se añaden usuarios al grupo posteriormente, se aplicarán las mismas restricciones de seguridad de forma automática.
* Si los usuarios se eliminan, las restricciones de seguridad no se aplicarán.

Sintaxis de creación de grupos:
CREATE GROUP <group> [WITH [SYSID <gid>][USER <user>[,...]]];

Ejercicio de Creación de grupos:
Los usuarios:
CREATE USER usuario1 PASSWORD '123';
CREATE USER usuario2 PASSWORD '123';
CREATE USER usuario3 PASSWORD '123';
CREATE USER usuario4 PASSWORD '123';
Se comprueba:
SELECT * FROM pg_user;
\du;
Los grupos:
CREATE GROUP grupo1;
CREATE GROUP grupo2 WITH USER usuario3, usuario4;
Se verifican:
SELECT * FROM pg_group;
Se añaden usuarios a un grupo:
ALTER GROUP grupo1 ADD USER usuario1,usuario2;
ALTER GROUP grupo2 ADD USER usuario1,usuario2;
Se le dan los siguientes privilegios (y se crean 2 tablas):
CREATE TABLE tabla1 (idTabla1 NUMERIC(2,0));
CREATE TABLE tabla2 (idTabla2 NUMERIC(2,0));
GRANT INSERT ON tabla1 TO PUBLIC;
GRANT SELECT,UPDATE ON tabla1 TO usuario2;
GRANT ALL PRIVILEGES ON tabla2 TO usuario3;
GRANT ALL PRIVILEGES ON tabla2 TO usuario1 WITH GRANT OPTION;
Se verifican:
\z tabla1;
\z tabla2;
Se borra un grupo:
DROP GROUP grupo2;
Se verifica:
SELECT * FROM pg_group;
Se elimina los privilegios de un usuario:
REVOKE ALL PRIVILEGES ON tabla1 FROM usuario2;
Se verifica:
\z tabla1;
Eliminamos usuarios:
DROP USER usuario2;
REVOKE ALL PRIVILEGES ON tabla2 FROM usuario1;
DROP USER usuario1;
SELECT * FROM pg_user;

Administración de roles:
PostgreSQL gestiona permisos a través del concepto de "roles". Los roles se pueden manipular para parecerse a las convenciones de grupo o de usuario, pero también son más flexibles. Es decir: los roles pueden ser miembros de otros roles, lo que les permite asumir las características de permisos de los roles definidos previamente. Los roles también pueden poseer objectos y controlar su acceso para otros roles.

El concepto de roles contiene los conceptos de "usuarios" y "grupos".
Cualquier rol puede actuar como un usuario, un grupo o ambos.
También se pueden ver como grupos y usarse para hacer que los privilegios sean más fáciles de administrar, considerando la jerarquía y la herencia de roles.

Sintaxis de creación de roles:
CREATE ROLE <role> [ [WITH] <option> [...] ]
where option can be:
...

<diagrama1>
CREATE TABLE table1 (idTable1 NUMERIC(2,0));
CREATE TABLE table2 (idTable2 NUMERIC(2,0));
CREATE TABLE table3 (idTable3 NUMERIC(2,0));
GRANT SELECT ON table1 TO user1;
GRANT SELECT ON table2 TO user1;
GRANT INSERT ON table1 TO user2;
GRANT UPDATE ON table1 TO user1;
GRANT UPDATE ON table3 TO user3;

<diagrama2>
┌────────┬─────────┐
│  USER1 │  USER2  │
├────────┼─────────┤
│  test  │  test   │
│ table5 │ table1  │
│ table7 │ table15 │
└────────┴─────────┘
CREATE ROLE role1;
CREATE ROLE role2;
GRANT SELECT ON table1 TO role1;
GRANT SELECT ON table2 TO role1;
GRANT INSERT ON table1 TO role2;
GRANT UPDATE ON table3 TO role2;
GRANT role2 TO user1;
GRANT role2 TO user3;
GRANT role1 TO user2;

El user1 tendrá los permisos de role1?
┌───────┐   ┌───────┐   ┌───────┐
│ Role1 │==>│ Role2 │==>│ User1 │
└───────┘   └───────┘   └───────┘
CREATE ROLE role1;
CREATE ROLE role2;
GRANT role1 TO role2;
GRANT role2 TO user1;
Si lo hereda, pero dependerá de la opción que se le haya puesto cuando se creo el role2 de si se creo con la opción de INHERENT (heredar) o con la opción de NOINHERENT (no heredar). Si se creo con la opción de INHERENT si tendrá los permisos de role1.

Ejercicio administración de roles 1/4
* Creamos una BD:
CREATE DATABASE prueba2;
* Revocamos los permisos al grupo público:
REVOKE ALL ON DATABASE prueba2 FROM public;
* Conectados en la base prueba, revocamos los permisos sobre el esquema público al grupo público:
\c prueba2;
REVOKE ALL ON SCHEMA PUBLIC FROM PUBLIC;
* Creamos los grupos:
CREATE ROLE lectura WITH NOLOGIN;
CREATE ROLE escritura WITH NOLOGIN;

Ejercicio administración de roles 2/4
* Asignamos permisos de conexión a la BD prueba2:
GRANT CONNECT ON DATABASE prueba2 TO lectura;
GRANT CONNECT ON DATABASE prueba2 TO escritura;
* Asignamos permisos de uso en el esquema público:
GRANT USAGE ON SCHEMA PUBLIC TO lectura;
GRANT USAGE ON SCHEMA PUBLIC TO escritura;
* Para el grupo de sólo lectura, asignamos los respectivos permisos para tablas/vistas actuales:
GRANT SELECT ON ALL TABLES IN SCHEMA PUBLIC TO lectura;

Ejercicio administración de roles 3/4
* Ahora lo dejamos configurado para cada tabla que se cree:
ALTER DEFAULT PRIVILEGES IN SCHEMA PUBLIC GRANT SELECT ON TABLES TO lectura;
* Para el grupo de escritura, asignamos los respectivos permisos para tablas/vistas actuales:
GRANT SELECT,INSERT,UPDATE,DELETE ON ALL TABLES IN SCHEMA PUBLIC TO escritura;
* Ahora lo dejamos configurado para cada tabla que se cree:
ALTER DEFAULT PRIVILEGES IN SCHEMA PUBLIC GRANT SELECT,INSERT,UPDATE,DELETE ON TABLES TO escritura;

Ejercicio administración de roles 4/4
* Asignamos permisos de uso para las secuencias:
GRANT USAGE ON ALL SEQUENCES IN SCHEMA PUBLIC TO escritura;
* Ahora lo dejamos configurado para cada secuencia que se cree:
ALTER DEFAULT PRIVILEGES IN SCHEMA PUBLIC GRANT USAGE ON SEQUENCES TO escritura;
* Si nos piden usuario de sólo lectura en la BD:
CREATE USER user_select WITH PASSWORD 'user_select' IN GROUP lectura;
* Si nos piden un usuario de escritura en la BD:
CREATE USER user_write WITH PASSWORD 'user_write' IN GROUP escritura;

Examen:
CREATE DATABASE examen;
\c examen;
Crear 3 grupos (grupo1,grupo2,grupo3).
CREATE GROUP grupo1;
CREATE GROUP grupo2;
CREATE GROUP grupo3;
--CREATE GROUP grupo2 WITH USER usuario3, usuario4;
Crear los usuarios (user01,user02,user03,user04,user05,user06).
	Donde el grupo1 tenga user01,user02,user03 y los privilegios de INSERT y SELECT.
	Donde el grupo2 tenga user01,user04,user05 y los privilegios de SELECT y DELETE.
	Donde el grupo3 tenga user06,user02 y todos los privilegios.
CREATE USER user01 WITH IN GROUP grupo1, grupo2;
CREATE USER user02 WITH IN GROUP grupo1, grupo3;
CREATE USER user03 WITH IN GROUP grupo1;
CREATE USER user04 WITH IN GROUP grupo2;
CREATE USER user05 WITH IN GROUP grupo2;
CREATE USER user06 WITH IN GROUP grupo3;

CREATE TABLE tabla1 (tabla1 NUMERIC(2,0));
CREATE TABLE tabla2 (tabla2 NUMERIC(2,0));
CREATE TABLE tabla3 (tabla3 NUMERIC(2,0));

GRANT INSERT,SELECT ON tabla1 TO grupo1;
GRANT SELECT,DELETE ON tabla2 TO grupo2;
GRANT ALL PRIVILEGES ON tabla3 TO grupo3;

SELECT * FROM pg_group;
SELECT * FROM pg_roles;
\du;
\z;
En word



Ejercicio role with no NoInherit --A reparar
CREATE DATABASE modulo6;
\c modulo6
CREATE TABLE usuarios(nombre VARCHAR(30), clave VARCHAR(10));
CREATE ROLE role0 WITH NOINHERIT;
GRANT SELECT,UPDATE,INSERT ON usuarios TO role0;
CREATE ROLE role3;
CREATE USER miguel WITH PASSWORD '123';
GRANT role0 TO role3;
GRANT role3 TO miguel;
\z
\du
\c modulo6 miguel --Cambia a modulo6 con el usuario miguel
GRANT CONNECT ON DATABASE modulo6 TO miguel;
\c modulo6 miguel
INSERT INTO usuarios (clave,nombre) VALUES ('River','Juan');
SELECT * FROM usuarios;



Respaldos
Hacer copias de las tablas de sistema, los objetos creados por el programador (tablas, vistas, procedimientos almacenados, restricciones, etc.) y los datos del usuario. Es el DBA el encargado de realizar esta labor mediante un esquema de respaldo (backup). El respaldo es lo que permite al administrador recuperar los datos en caso de una contingencia, como puede ser: Fallas de disco, fallas de software, borrado o actualización accidental, virus, desastres naturales, robo, etc.

Para establecer su esquema, el DBA toma en cuenta los siguientes aspectos:
a) Con qué periodicidad debe realizarse el respaldo?
b) Qué se debe respaldar?
c) Qué medio electrónico se debe usar para el respaldo?
d) Debe efectuarse en línea o fuera de línea?
e) Existe un mecanismo para asegurarnos que el respaldo se hizo correctamente?
f) Dónde se almacenarán los respaldos?
g) Cuánto tiempo deben conservarse los respaldos?
h) Deben ser hechos de forma manual o automática?
i) Si son automáticos, como se verifican?
j) Cuando ocurre una falla, cuánto tiempo toma restaurar las BDs?

Algunas de las respuestas las encontramos al conocer el volumen de transacciones que se realizan sobre las BDs. Pensemos que un respaldo toma tiempo y distrae al procesador de su actividad normal, por lo que el DBMS deja de atender con la misma velocidad las transacciones de los usuarios. Por ello muchos respaldos se hacen por la noche o los fines de semana y de manera automática. El principio básico consiste en hacer los respaldos en horas en las que se efectúe el menor número de transacciones.
Y es recomendable verificar que los respaldos se hayan realizado correctamente, como realizando el restore sobre una nueva BD.
C:\Program Files\PostgreSQL\15\bin
pg_dump --help
pg_dump -U postgres -C -f C:\Users\oscar\respaldo.dump modulo6
psql
DROP DATABASE modulo6;
exit
psql -U postgres < C:\Users\oscar\respaldo.dump
pg_dumpall --help
pg_dumpall -U postgres -f C:\Users\oscar\respaldo_todo.dump

Script y Tarea automática
Archivo de texto que contiene comandos o porciones de código.

Tarea 3
Cambiar el en el script, pg_dump.exe por pg_dumpall.exe










Desarrollo de plan de contingencia

La información es uno de los activos más valiosos de una organización, y que la BD es la fuente primaria de esta información. La pérdida o corrupción de datos puede tener consecuencias graves y duraderas para una empresa, como la pérdida de clientes, la disminución de la productividad y la imagen negativa en el mercado.

¿Qué es un desastre?
Podríamos considerar al desastre como pérdida total o parcial de la información critica para la institución, durante un periodo considerable de tiempo, durante el cual la organización puede verse seriamente afectada en su operación.

Listado de los desastres más conocidos
Evento Año Causa
...

Plan de contingencia
En la actualidad los cambios tecnológicos adquieren cada vez mayor importancia al interior de las organizaciones, por lo cual se hace necesario e indispensable contar con un plan de contingencias, que garantice el restablecimiento del correcto funcionamiento de los servicios informáticos en el menor tiempo posible, ante cualquier eventualidad.
Un plan de contingencia es una estrategia planificada con una serie de procedimientos que nos faciliten o nos orienten a tener una solución alternativa que nos permita restituir rápidamente los servicios de la organización ante la eventualidad de todo lo que lo pueda paralizar, ya sea de forma parcial o total. Dicho plan contiene las medidas técnicas, humanas y organizativas necesarias para garantizar la continuidad de las operaciones de una empresa.

Importancia del plan de contingencia
La importancia de contar con un plan de contingencia en la BD es crucial para garantizar la integridad y la disponibilidad de los datos en una organización. Sin un plan...

Ejemplo problema de hardware
* Operaciones
* Clientes

Plan de contingencia
Objetivos del plan de contingencia
* Garantizar la continuidad de las operaciones de los elementos considerados críticos que componen los sistemas de información.
* Definir acciones y procedimientos a ejecutar en caso de fallas de los elementos que componen un sistema de información.

Normas
Organización Internacional de Normalización (ISO)
ISO/IEC 27001. Norma internacional que describe cómo gestionar la seguridad de la información en una organización. Específicamente de cómo establecer el SGSI (Sistema de Gestión de la Seguridad de la Información) y sobre cómo implementar y operar el SGSI.
ISO/IEC 27002. 2013 Es una guía de buenas prácticas para un SGSI que describe los objetivos de control y controles recomendados en cuanto a seguridad de la información.

Estructua de ISO 27001
Evaluación y tratamiento de riesgos -> Implementación de medidas de seguridad

Normas
ISO 22301:2012 norma...
ISO 27017: Código de prácticas...

Riesgos
Errores humanos: pueden incluir la eliminación accidental de datos importantes, la introducción de datos incorrectos o la modificación accidental de datos importantes.
Fallas de hardware: pueden incluir la falla de discos duros, la pérdida de energía, la falla de componentes de red o la falla de servidores.
Desastres naturales: pueden incluir terremotos, inundaciones, incendios y otros eventos que puedan dañar físicamente la infraestructura de TI.
Amenazas de seguridad: pueden incluir ataques cibernéticos, virus informáticos y otros actos maliciosos que puedan afectar la integridad de BD.

¿Tendra la misma repercusión una falla humana que una de hardware?
Un error humano que afecta a un solo registro puede tener un impacto menor en la organización, mientras que una falla de hardware que afecta a toda la BD puede tener un impacto significativo en la organización.

Organización que almacena información financiera confidencial.
Organización que almacena información no confidencial.

Existen diferentes planes de contingencia
Copias de seguridad: Crear copias...
Planes de recuperación ante desastres: Este...

<diagrama1>

Fase: Estategias de continuidad
Actividades preventivas
Las medidas preventivas requieren un detallado análisis previo de riesgos y vulnerabiliades. Algunos de ellos serán de carácter general: incendios, desastres naturales, etc., mientras que otros tendrán un carácter estrictamente informático: fallo de sistemas de almacenamiento, ciberataques, virus, etc.
Cold standby: ...
Hot standby: que...

Fase organización y planificación
El plan de respaldo. Contempla las contramedidas preventivas antes de que se materialice una amenaza. Su finalidad es evitar dicha materialización.
El plan de emergencia...

Plan de respaldo
Es un conjunto de acciones utilizadas para evitar el fallo o, en us caso, aminorar las consecuencias que dé el se puedan derivar.
Ubicación del centro...
Ubicación del edificio...

Plan de emergencia
La crisis suelen provocar "reacciones de pánico" que pueden ser contraproducentes y a veces...
Realizar un análisis de aplicaciones críticas...
Determinar las prioridades...

Plan de recuperación
Los contratos de seguros...





Tarea - 5 características del desarrollo del plan de contingencia
Algunos riesgos y vulnerabiliades son informáticos (fallo de sistemas de almacenamiento, ciberataques, virus, etc.), y otros no (incendios, desastres naturales, etc.).
Errores humanos: pueden incluir la eliminación accidental de datos importantes, la introducción de datos incorrectos o la modificación accidental de datos importantes.
Fallas de hardware: pueden incluir la falla de discos duros, la pérdida de energía, la falla de componentes de red o la falla de servidores.
Desastres naturales: pueden incluir terremotos, inundaciones, incendios y otros eventos que puedan dañar físicamente la infraestructura de TI.
Amenazas de seguridad: pueden incluir ataques cibernéticos, virus informáticos y otros actos maliciosos que puedan afectar la integridad de BD.


https://dev.mysql.com/doc/refman/8.0/en/create-temporary-table.html#:~:text=To%20create%20a%20temporary%20table,INSERT%20,%20UPDATE%20,%20or%20SELECT%20.















MÓDULO VIII
MANEJADORES DE BASES DE DATOS COMERCIALES
1. PostgreSQL
2. Oracle
3. DB2 Universal Database
4. SQL Server
5. Otros

1. PostgreSQL no tiene procedimientos almacenados, porque PostgreSQL es un modelo orientado a objetos.
Las funciones retornan un valor, por lo tanto se pueden utilizar estructuras de control y por lo tanto se puede programar dentro de PostgreSQL, mediante las funciones.
Los procedimientos almacenados no retornan un valor.

PostgreSQL además del modelo relacional, incorpora 4 conceptos:
* Clases
* Herencia
* Tipos
* Funciones

Con la llegada de la GUI, se empezo a programar en OO, para programar comportamientos de los eventos de la GUI.

Otras características aportan potencia y flexibilidad adicional:
* Restricciones (Constraints)
* Disparadores (Triggers)
* Reglas (rules)
* Integridad transaccional

El codigo de PostgreSQL fue adaptado a ANSIC y su tamaño reducido en un 25%.

2. Oracle
Cliente-Servidor
Tener Oracle 8i y manejar la bd desde otros equipos con herramientas de desarrollo como Oracle Designer y Oracle Developer.
Programar con el lenguaje de programación PL/SQL de Oracle.
Oracle Designer se conecta con la BD, y se puede crear formularios.
Shared Pool: Almacena el diccionario de datos (DATA DICTIONARY CACHE) y las sentencias SQL recientemente utilizadas (SHARED SQL o LIBRARY CACHE). Es donde tiene lugar la fase de analisis de las sentencias SQL (PARSING). Para definir su ...

3. DB2

4. SqlServer
En el 2012 se puede cifrar las BDs.


https://www.freecodecamp.org/news/an-administrator-has-blocked-you-from-running-this-app-how-to-fix-on-a-windows-10-pc/













































